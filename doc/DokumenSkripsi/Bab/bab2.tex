%versi 2 (8-10-2016)
\chapter{Landasan Teori}
\label{chap:teori}

Pada bab ini akan dijelaskan landasan teori mengenai \textit{WebSockets}, \textit{Socket.io}, \textit{Node.js}, \textit{Express.js}, dan \textit{Canvas API}.

\section{WebSockets}
\label{sec:WebSockets} 

\textit{WebSockets} merupakan \textit{Application Programming Interface (API)} yang memiliki kemampuan untuk membuka sesi komunikasi interaktif antara \textit{browser} pengguna dan \textit{server} \cite{websockets}. Dengan \textit{API} ini, pengguna dapat mengirim pesan ke \textit{server} dan menerima respon tanpa harus melakukan \textit{polling} pada \textit{server} terlebih dahulu.

Subbab-subbab berikut menjelaskan kelas-kelas yang ada pada \textit{WebSockets}.

\subsection{WebSocket}
Kelas ini merupakan inti untuk mengakses fungsi yang ada pada \textit{WebSockets}. Sebuah objek \textit{WebSocket} dapat membuat dan mengelola koneksi \textit{WebSocket} ke server, serta dapat mengirim dan menerima data pada koneksi tersebut. 

%Sebuah objek dari kelas \textit{WebSocket} menyediakan \textit{API} untuk membuat dan mengelola koneksi \textit{WebSocket} ke \textit{server}, dan juga untuk mengirim dan menerima data pada koneksi. \textit{Constructor} pada kelas \textit{WebSocket} menerima satu parameter wajib dan satu parameter pilihan. 

Berikut merupakan konstruktor dari kelas \textit{WebSocket}: 
\begin{lstlisting}
	WebSocket WebSocket(in DOMString url, in optional DOMString protocols);
\end{lstlisting}

\begin{itemize}
	\item \textbf{url}, parameter wajib yang menunjukan \textit{URL} mana yang akan direspon oleh \textit{WebSocket server}.
	
	\item \textbf{protocols}, parameter pilihan (tidak harus ada pada parameter) yang dapat berupa satu \textit{string} atau \textit{array of strings}. Parameter \textit{protocols} merepresentasikan nama dari subprotokol yang akan digunakan oleh objek \textit{WebSocket}. Apabila subprotokol tersedia pada parameter, maka \textit{server} akan memeriksa apakah subprotokol tersebut dapat diterima atau tidak. \textit{Server} akan memberikan respon apabila subprotokol dapat diterima, dan akan menghasilkan suatu \textit{error} apabila tidak dapat diterima. Contoh subprotokol yang dapat digunakan yaitu:
	\begin{itemize}
		\item \textbf{chat}
		\item \textbf{superchat}
	\end{itemize}
	
\end{itemize}

Konstruktor dari kelas \textit{WebSocket} dapat menampilkan suatu \textit{exception} seperti berikut:

\begin{lstlisting}
	SECURITY_ERR
\end{lstlisting}

\textit{Exception} tersebut menandakan bahwa \textit{port} yang akan digunakan untuk melakukan koneksi diblokir.

Atribut yang dimiliki oleh kelas \textit{WebSocket} yaitu:

\begin{itemize}
	\item \textbf{binaryType} \\ tipe: \textbf{DOMString} \\ Sebuah \textit{string} yang menandakan tipe dari data biner yang dikirimkan oleh koneksi tertentu. Nilai dari atribut ini dapat berupa \textit{"ArrayBuffer"} apabila objek dari \textit{ArrayBuffer} digunakan.
	
	\item \textbf{bufferedAmount} \\ tipe: \textbf{unsigned long} \\ Jumlah \textit{bytes} dari data yang belum dikirimkan oleh \textit{method} \textbf{send()}. Nilai dari atribut ini akan kembali menjadi nol apabila seluruh data sudah dikirimkan. Apabila koneksi terputus, nilai atribut ini tidak akan kembali menjadi nol dan akan tetap bertambah apabila terus dilakukan pemanggilan pada \textit{method} \textbf{send()}.
	
	\item \textbf{onclose} \\ tipe: \textbf{EventListener} \\ \textit{Event listener} yang dipanggil saat atribut \textit{readyState} dalam koneksi \textit{WebSocket} berubah menjadi \textit{CLOSED}. \textit{Listener} akan menerima objek dari \textit{CloseEvent} dengan nilai \textit{"close"}.
	
	\item \textbf{onerror} \\ tipe: \textbf{EventListener} \\ \textit{Event listener} yang dipanggil saat terjadi \textit{error}. \textit{Event} tersebut akan bernilai \textit{"error"}.
	
	\item \textbf{onmessage} \\ tipe: \textbf{EventListener} \\ \textit{Event listener} yang dipanggil saat atribut \textit{readyState} dalam koneksi \textit{WebSocket} berubah menjadi \textit{OPEN}. Hal tersebut menandakan bahwa koneksi sudah siap untuk mengirim dan menerima data. \textit{Event} tersebut akan bernilai \textit{"open"}.
	
	\item \textbf{protocol} \\ tipe: \textbf{DOMString} \\ \textit{String} yang menandakan sebuah nama dari sub-protokol yang dipilih oleh \textit{server}. Atribut ini akan menjadi salah satu masukan parameter yang dibutuhkan untuk konstruksi kelas \textit{WebSocket}.
	
	\item \textbf{readyState} \\ tipe: \textbf{unsigned short} \\ Menunjukan kondisi koneksi saat ini. Atribut ini memiliki beberapa konstanta yang menunjukan kondisi dari koneksi \textit{WebSocket}. Konstanta tersebut sebagai berikut:
		\begin{itemize}
			\item \textbf{CONNECTING} \\ nilai: 0 \\ Koneksi belum terbuka.
			\item \textbf{OPEN} \\ nilai: 1 \\ Koneksi sudah terbuka dan siap untuk melakukan komunikasi.
			\item \textbf{CLOSING} \\ nilai: 2 \\ Koneksi sedang dalam proses menutup.
			\item \textbf{CLOSED} \\ nilai: 3 \\ Koneksi sudah tertutup atau tidak dapat dibuka.
		\end{itemize}
	
	\item \textbf{url} \\ tipe: \textbf{DOMString} \\ \textit{URL} yang akan dituju oleh objek \textit{WebSocket}. Atribut ini akan menjadi salah satu masukan parameter untuk konstruksi kelas \textit{WebSocket}.
\end{itemize}

Kelas \textit{WebSocket} memiliki dua buah \textit{method}, yaitu:

\begin{itemize}
	\item \textbf{void close(in optional unsigned long code, in optional DOMString reason)} \\ Berfungsi untuk menutup suatu koneksi atau menghentikan proses koneksi. \\ \textbf{Parameter:} 
		\begin{itemize}
			\item \textbf{code} nilai numerik yang menunjukan kode status, yang menjelaskan mengapa suatu koneksi ditutup. Apabila parameter ini tidak tersedia, maka akan diasumsikan dengan nilai \textit{default} yaitu 1000 yang berarti transaksi selesai.
			\item \textbf{reason} \textit{string} yang menjelaskan mengapa suatu koneksi ditutup. 
		\end{itemize}
	\textit{Method} ini dapat melemparkan eksepsi seperti berikut:
		\begin{itemize}
			\item \textbf{INVALID\_ACCESS\_ERR} parameter \textit{code} yang tidak valid.
			\item \textbf{SYNTAX\_ERR} parameter \textit{reason} yang melebihi batas yang telah ditentukan.
		\end{itemize}
	
	\item \textbf{void send(in DOMString data)} \\ Berfungsi untuk mengirimkan data ke \textit{server} melalui koneksi \textit{WebSocket}, dan menambah nilai dari \textit{bufferedAmount} sebanyak jumlah \textit{bytes} yang dibutuhkan untuk menampung data. \\ \textbf{Parameter} \\ Tipe data yang dikirimkan pada parameter dapat berbeda-beda, Beberapa tipe tersebut yaitu sebagai berikut:
	
		\begin{itemize}
			\item \textbf{USVString} sebuah teks \textit{string} yang ditambahkan ke \textit{buffer} dalam format \textit{UTF-8}. Nilai dari \textit{bufferedAmount} akan bertambah sesuai dengan jumlah \textit{bytes} yang dibutuhkan untuk menyimpan \textit{UTF-8 string}.
			
			\item \textbf{ArrayBuffer} data biner yang disimpan pada \textit{fixed-length buffer}, dimana objek dari \textit{ArrayBuffer} dimanipulasi oleh objek \textit{TypedArray}.
		\end{itemize}
	\textit{Method} ini dapat melemparkan eksepsi seperti berikut:
	\begin{itemize}
		\item \textbf{INVALID\_STATE\_ERR} koneksi saat ini tidak terbuka.
		\item \textbf{SYNTAX\_ERR} parameter \textit{data} tidak valid.
	\end{itemize}
\end{itemize}

\subsection{CloseEvent}
Kelas ini akan menangani koneksi \textit{WebSocket} yang ditutup. Objek \textit{CloseEvent} akan dikirim ke \textit{client} saat koneksi ditutup. Objek tersebut akan dikirimkan ke \textit{listener} yang ditunjukan oleh atribut \textit{onclose} milik objek \textit{WebSocket}.

Konstruksi kelas ini yaitu:

\begin{itemize}
	\item \textbf{new CloseEvent(typeArg, closeEventInit);} \\ \textbf{Parameter:} 
		\begin{itemize}
			\item \textbf{typeArg} \\ tipe: \textbf{DOMString} \\ nama dari suatu \textit{event} yang akan dikirimkan.
			\item \textbf{closeEventInit} bersifat pilihan, dan memiliki beberapa nilai sebagai berikut:
				\begin{itemize}
					\item \textit{"wasClean"} \\ tipe: \textbf{boolean} \\ menunjukan apakah koneksi sudah ditutup dengan baik atau belum.
					\item \textit{"code"} \\ tipe: \textbf{unsigned short} \\ kode status yang menunjukan mengapa koneksi ditutup.
					\item \textit{"reason"} \\ tipe: \textbf{DOMString} \\ teks yang menunjukan alasan mengapa koneksi ditutup oleh \textit{server}.
				\end{itemize}
		\end{itemize}
\end{itemize}

Berikut merupakan nilai-nilai dari kode status koneksi ditutup:

\begin{itemize}
	\item \textbf{0-999} \\ nama: - \\ \textit{Reserved}. Tidak digunakan.
	
	\item \textbf{1000} \\ nama: \textbf{Normal Closure} \\ Penutupan normal, yang berarti koneksi sudah menyelesaikan apapun tujuan dari koneksi tersebut.
	
	\item \textbf{1001} \\ nama: \textbf{Going Away} \\ \textit{Endpoint} menghilang karena kesalahan server atau \textit{browser} tidak lagi mengakses halaman yang sudah membuka koneksi.
	
	\item \textbf{1002} \\ nama: \textbf{Protocol Error} \\ \textit{Endpoint} menghentikan koneksi karena adanya kesalahan protokol.
	
	\item \textbf{1003} \\ nama: \textbf{Unsupported Data} \\ Koneksi dihentikan karena \textit{endpoint} menerima data dengan tipe yang tidak bisa diterima (contoh: \textit{text-only endpoint} menerima data biner).
	
	\item \textbf{1004} \\ nama: - \\ \textit{Reserved}. Makna dari kode tersebut akan dijelaskan di waktu yang akan datang.
	
	\item \textbf{1005} \\ nama: \textbf{No Status Recieved} \\ \textit{Reserved}. Menandakan bahwa tidak ada kode status yang tersedia.
	
	\item \textbf{1006} \\ nama: \textbf{Abnormal Closure} \\ \textit{Reserved}. Menandakan bahwa koneksi ditutup secara tidak normal (contoh: tidak ada \textit{close frame} yang dikirimkan).
	
	\item \textbf{1007} \\ nama: \textbf{Invalid frame payload data} \\ \textit{Endpoint} menghentikan koneksi karena pesan yang diterima berisi data yang tidak konsisten (contoh: data \textit{non-UTF-8} berada di dalam pesan teks).
	
	\item \textbf{1008} \\ nama: \textbf{Policy Violation} \\ \textit{Endpoint} menghentikan koneksi karena menerima pesan yang melanggar kebijakan. Kode status ini dapat digunakan apabila tidak ada kode status lain yang cocok atau digunakan untuk tidak menunjukan kebijakan lebih rinci.
	
	\item \textbf{1009} \\ nama: \textbf{Message too big} \\ \textit{Endpoint} menghentikan koneksi karena menerima \textit{frame} data yang terlalu besar.
	
	\item \textbf{1010} \\ nama: \textbf{Missing Extension} \\ \textit{Client} menghentikan koneksi karena \textit{server} tidak menangani satu atau beberapa ekstensi yang diminta oleh \textit{client}.
	
	\item \textbf{1011} \\ nama: \textbf{Internal Error} \\ \textit{Server} menghentikan koneksi karena mengalami kondisi tertentu yang menyebabkan tidak bisa memenuhi permintaan \textit{client}.
	
	\item \textbf{1012} \\ nama: \textbf{Service Restart} \\ \textit{Server} menghentikan koneksi karena harus mengulang kembali koneksi.
	
	\item \textbf{1013} \\ nama: \textbf{Try Again Later} \\ \textit{Server} menghentikan koneksi karena ada kondisi yang harus ditangani untuk sementara (contoh: \textit{overloaded}).
	
	\item \textbf{1014} \\ nama: \textbf{Bad Gateway} \\ \textit{Server} bertindak sebagai \textit{gateway} atau \textit{proxy} dan menerima respon yang tidak benar dari \textit{upstream server}.
	
	\item \textbf{1015} \\ nama: \textbf{TLS Handshake} \\ \textit{Reserved}. Menandakan bahwa koneksi ditutup karena gagal melakukan \textit{TLS handsake} (contoh: sertifikat \textit{server} tidak dapat diverifikasi).
	
	\item \textbf{1016-1999} \\ nama: - \\ \textit{Reserved}. Akan digunakan oleh standar \textit{WebSocket} di waktu yang akan datang.
	
	\item \textbf{2000-2999} \\ nama: - \\ \textit{Reserved}. Akan digunakan oleh ekstensi \textit{WebSocket}.
	
	\item \textbf{3000-3999} \\ nama: - \\ Tersedia untuk digunakan oleh \textit{libraries} dan \textit{frameworks}.
	
	\item \textbf{4000-4999} \\ nama: - \\ Tersedia untuk digunakan oleh aplikasi.
\end{itemize}

\subsection{MessageEvent}
Kelas ini merepresentasikan pesan yang diterima oleh suatu objek tertentu. \textit{Constructor} dari kelas ini yaitu: 

\begin{lstlisting}
	MessageEvent()
\end{lstlisting}

Beberapa properti yang dimiliki oleh kelas ini yaitu: 

\begin{itemize}
	\item \textbf{MessageEvent.data} \\ Merupakan data yang telah dikirimkan oleh pengirim.
	\item \textbf{MessageEvent.lastEventId} \\ Merepresentasikan \textit{ID} yang unik untuk sebuah \textit{Event}.
\end{itemize}

Contoh penggunaan dari beberapa properti tersebut sebagai berikut:

\begin{lstlisting}
	//MessageEvent.data
	myWorker.onmessage = function(e) {
	result.textContent = e.data;
	console.log('Message received from worker');
	};
	
	//MessageEvent.lastEventId
	myWorker.onmessage = function(e) {
	result.textContent = e.data;
	console.log('Message received from worker');
	console.log(e.lastEventId);
	};
\end{lstlisting}


%-------------REVISED LIMIT OF WEBSOCKETS---------

\section{Socket.io}
\label{sec:Socket.io}

\textit{Socket.io} merupakan salah satu teknologi yang memanfaatkan protokol \textit{WebSockets} \cite{socketio}. Teknologi ini memungkinkan sebuah aplikasi untuk melakukan komunikasi dua arah secara \textit{real-time}. \textit{Socket.io} dapat dijalankan di setiap \textit{platform, browser}, dan gawai.

Sebelum dapat menggunakan \textit{socket.io}, \textit{Node.js} harus sudah ter\textit{install} pada sistem komputer. Apabila hal tersebut sudah dilakukan, maka \textit{socket.io} dapat di\textit{install} dengan menggunakan \textit{command line tools} atau sejenisnya dengan melakukan langkah seperti berikut:
\begin{lstlisting}
	npm install socket.io
\end{lstlisting}

Dengan begitu, aplikasi yang dibuat sudah dapat mengakses fitur-fitur yang dimiliki oleh \textit{socket.io}.

\textit{Socket.io} dibagi menjadi dua \textit{API}, yaitu \textit{Server API} dan \textit{Client API}. Subbab-subbab berikut menjelaskan kelas-kelas yang dimiliki \textit{Socket.io}.

\subsection{Server API}
Kelas-kelas yang ada pada \textit{Server API} digunakan untuk menangani proses yang terjadi dalam \textit{server}\cite{socketioserver}. Kelas-kelas tersebut adalah sebagai berikut:

\begin{enumerate}
	\item \textbf{Server} \\ Kelas ini merupakan inti untuk dapat menangani proses yang terjadi dalam \textit{socket.io server}. Kelas ini memiliki tiga konstruktor seperti berikut: 
	\begin{itemize}
		\item \textbf{new Server(httpServer[, options])} \\ 
		\textbf{Parameter:}
		\begin{itemize}
			\item \textbf{httpServer} \\ tipe: \textbf{http.Server} \\ \textit{Server} yang akan dituju.
			\item \textbf{options} \\ tipe: \textbf{Object} \\ Parameter ini dapat berupa berbagai jenis objek. Objek-objek tersebut yaitu sebagai berikut: 
			\begin{itemize}
				\item \textbf{path} \\ tipe: \textbf{String} \\ Nama dari path yang akan ditangkap oleh \textit{server} (contoh: \textit{/socket.io}).
				
				\item \textbf{serveClient} \\ tipe: \textbf{Boolean} \\ Menunjukan apakah \textit{server} akan melayani \textit{file} dari \textit{client} atau tidak.
				
				\item \textbf{adapter} \\ tipe: \textbf{Adapter} \\ Objek yang akan mengatur beberapa \textit{socket} untuk menerima koneksi, dan mengirimkan pesan antara satu \textit{socket} dengan \textit{socket} lainnya.
				
				\item \textbf{origins} \\ tipe: \textbf{String} \\ \textit{Origins} yang diperbolehkan oleh \textit{server}.
				
				%\item \textbf{parser} \\ tipe: \textbf{Parser} \\ \textit{Parser} yang akan digunakan oleh \textit{server}.
			\end{itemize}
		\end{itemize}
	
		Untuk dapat menggunakan fitur yang ada pada \textit{socket.io}, harus menambahkan modul \textit{socket.io} pada konstanta tertentu. Hal tersebut dapat dilakukan dengan dua cara, yaitu menggunakan kata kunci \textit{new} atau tanpa menggunakan kata kunci \textit{new}:
		
		\begin{itemize}
			\item Menggunakan \textit{new}
			\begin{lstlisting}
	const Server = require('socket.io');
	const io = new Server();
			\end{lstlisting}
			
			\item Tanpa menggunakan \textit{new}
			\begin{lstlisting}
	const io = require('socket.io')();
			\end{lstlisting}
		\end{itemize}
	
	Contoh implementasi konstruktor:
	
	\begin{lstlisting}
	const Server = require('socket.io');
	const http = require('http').createServer();
		
	const io = new Server(http, {
		path: '/test',
		serveClient: false
	});
	\end{lstlisting}
	
	\item \textbf{new Server(port[,options])} \\
	\textbf{Parameter:}
	\begin{itemize}
		\item \textbf{port} \\ tipe: \textbf{Number} \\ Nomor \textit{port} yang akan dituju.
		\item \textbf{options} \\ tipe: \textbf{Object} \\ Sama seperti konstruktor pertama, parameter ini dapat berupa berbagai jenis objek.
	\end{itemize}
	
	Contoh implementasi konstruktor: 
	\begin{lstlisting}
	const Server = require('socket.io');
	const io = new Server(3000, {
		path: '/test',
		serveClient: false
	});
	\end{lstlisting}
	
	\item \textbf{new Server(options)} \\ 
	\textbf{Parameter:}
	
		\begin{itemize}
			\item \textbf{options} \\ tipe: \textbf{Object} \\ Sama seperti konstruktor pertama, parameter ini dapat berupa berbagai jenis objek.
		\end{itemize}
	
	Contoh implementasi konstruktor:
	
	\begin{lstlisting}
	const Server = require('socket.io');
	const io = new Server({
		path: '/test',
		serveClient: false
	});
	\end{lstlisting}
	
	\end{itemize}

	Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu sebagai berikut: 
	
		\begin{itemize}
			\item \textbf{server.serveClient([value])} \\ 
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{value} \\ tipe: \textbf{Boolean}
			\end{itemize}
			\textbf{Kembalian:} \textit{Server} atau \textit{Boolean}. \\
			Apabila parameter \textit{value} bernilai \textit{true}, maka \textit{server} akan menangani \textit{file} dari \textit{client}. Apabila tidak ada argumen pada \textit{method} ini, maka kembalian akan berupa status \textit{default} dari \textit{serveClient} saat ini (\textit{true}).
			
			\item \textbf{server.path([value])} \\
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{value} \\ tipe: \textbf{String}
			\end{itemize}
			\textbf{Kembalian:} \textit{Server} atau \textit{String} \\
			Parameter \textit{value} akan menetapkan nilai dari \textit{path} yang akan dituju. Secara \textit{default} nilai dari \textit{path} akan diisi dengan \textit{/socket.io}. Apabila tidak ada argumen pada \textit{method} ini, maka kembalian akan berupa nilai dari \textit{value} saat ini.
			
			Berikut contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
	const io = require('socket.io')();
	io.path('/myownpath');
	\end{lstlisting}
	
			\item \textbf{server.adapter([value])} \\
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{value} \\tipe: \textbf{Adapter} \\ objek \textit{Adapter} yang akan digunakan.
			\end{itemize}
			\textit{Method} ini akan menentukan \textit{adapter} apa yang akan digunakan. Secara \textit{default} adapter yang akan digunakan merupakan objek \textit{adapter} yang berasal dari \textit{socket.io} yang bekerja berdasarkan memori. Apabila \textit{method} ini tidak menerima parameter, maka kembalian akan berupa \textit{adapter} saat ini (secara \textit{default}).
			
			Berikut contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
	const io = require('socket.io')(3000);
	const redis = require('socket.io-redis');
	io.adapter(redis({ host: 'localhost', port: 6379}));
	\end{lstlisting}
	
			\item \textbf{server.origins([value])} \\ 
			\textbf{Parameter:} 
			\begin{itemize}
				\item \textbf{value} \\tipe: \textbf{String} \\ Menunjukan \textit{origin} mana yang diizinkan oleh \textit{server}.
			\end{itemize}
			\textbf{Kembalian:} \textit{Server} atau \textit{String}
			
			\textit{Method} ini akan menetapkan \textit{origins} mana yang diizinkan oleh \textit{server}. Secara \textit{default}, \textit{origins} yang diizinkan dapat dari mana saja.
			
			Berikut contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
	const io = require('socket.io')();
	io.origins(['foo.example.com:443']);
	\end{lstlisting}
			
			\item \textbf{server.attach(httpServer[, options])} \\
			\textbf{Parameter:} 
			\begin{itemize}
				\item \textbf{httpServer} \\tipe: \textbf{http.Server} \\ \textit{Server} yang akan dihubungkan.
				\item \textbf{options} \\tipe: \textbf{Object} \\ Sama seperti konstruktor \textit{new Server(httpServer[, options])}, parameter ini dapat berupa berbagai jenis objek.
			\end{itemize}
			\textit{Method} ini akan menghubungkan \textit{Server} dengan objek dari \textit{engine.io} pada parameter \textit{httpSErver} dengan diberikan suatu \textit{options}.
			
			\item \textbf{server.bind(engine)} \\
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{engine} \\tipe: \textbf{engine.Server}
			\end{itemize}
			\textbf{Kembalian:} \textit{Server}
			
			\textit{Method} ini akan menghubungkan \textit{server} dengan objek \textit{Server} dari \textit{engine.io}.
			
			\item \textbf{server.close([callback])} \\
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{callback} \\tipe: \textbf{Function} \\ Fungsi \textit{callback}.
			\end{itemize}
			\textit{Method} ini akan menutup koneksi \textit{server socket.io}. Parameter \textit{callback} bersifat opsional dan akan dipanggi saat semua koneksi sudah ditutup.
		
		
			
		\end{itemize}

	\item \textbf{Namespace}
	
	\item \textbf{Socket}
	
	\item \textbf{Client}  
	
\end{enumerate}
	
\subsubsection{Namespace}
Kelas ini merepresentasikan kumpulan dari \textit{sockets} yang terhubung dalam lingkup tertentu, yang diidentifikasi oleh sebuah \textit{pathname}. \textit{Client} selalu terhubung ke \textit{/} (\textit{namespace} utama), kemudian dapat terhubung ke \textit{namespace} lainnya ketika menggunakan koneksi yang sama.

Beberapa properti yang dimiliki oleh kelas ini yaitu: 
\begin{itemize}
	\item \textbf{namespace.name} \\ Sebuah \textit{string} yang merupakan \textit{identifier} pada \textit{namespace}.
	\item \textbf{namespace.connected} \\ Sebuah \textit{hash} dari objek \textit{Socket} yang terhubung pada \textit{namespace} saat ini.
	\item \textbf{namespace.adapter} \\ Sebuah adaptor yang digunakan untuk \textit{namespace} tertentu.
\end{itemize}

Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu:

\begin{itemize}
	\item \textbf{namespace.emit(eventName[, ...args])} \\ Akan menyebarkan suatu \textit{event} ke semua \textit{clients} yang sedang melakukan koneksi.
	
	\item \textbf{namespace.client(callback)} \\ Akan mendapatkan daftar para \textit{clients} yang sedang terkoneksi dengan \textit{namespace} ini.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//namespace.emit
	const io = require('socket.io')();
	io.emit('an event sent to all connected clients');
	
	//namespace.client
	const io = require('socket.io')();
	io.of('/chat').clients((error, clients) => {
	if (error) throw error;
	console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]
	});
\end{lstlisting}

\subsubsection{Socket}
Kelas ini merupakan kelas yang sangat mendasar untuk melakukan interaksi dengan \textit{browser} milik \textit{client}. Sebuah \textit{Socket} dimiliki oleh \textit{Namespace} tertentu (secara \textit{default} menggunakan \textbf{/}).

Beberapa properti yang dimiliki oleh kelas ini yaitu : 
\begin{itemize}
	\item \textbf{socket.id} \\ Merupakan tanda pengenal yang unik untuk sesi tertentu.
	\item \textbf{socket.client} \\ Merupakan \textit{reference} ke objek \textit{Client} tertentu.
	\item \textbf{socket.request} \\ Merupakan \textit{getter proxy} yang mengembalikan referensi ke \textit{request} yang berasal dari \textit{Client} tertentu.
\end{itemize}

Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu : 
\begin{itemize}
	\item \textbf{socket.send([...args[, ack]])} \\ Berfungsi untuk mengirimkan pesan tertentu.
	\item \textbf{socket.emit(eventName[, ...args][, ack])} \\ Berfungsi untuk mengeluarkan suatu \textit{event} kepada \textit{socket} yang diidentifikasi oleh nama \textit{event} tersebut.
	\item \textbf{socket.disconnect(close)} \\ Berfungsi untuk mengakhiri koneksi milik \textit{client} saat ini.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//emit
	socket.emit('hello', 'world');
	
	//disconnect
	io.on('connection', (socket) => {
	setTimeout(() => socket.disconnect(true), 5000);
	});
\end{lstlisting}

\subsubsection{Client}
Kelas ini merepresentasikan koneksi \textit{transport} yang masuk\cite{socketioclient}. \textit{Client} dapat terhubung dengan beberapa \textit{Sockets} yang termasuk dalam \textit{Namespaces} yang berbeda.

Atribut-atribut yang dimiliki oleh kelas ini yaitu: 

\begin{itemize}
	\item \textbf{client.conn} \\ Merupakan referensi kepada koneksi \textit{Socket}.
	\item \textbf{client.request} \\ Berfungsi untuk mengakses \textit{header} dari \textit{request} seperti \textit{Cookie} atau \textit{User-Agent}.
\end{itemize}

\subsection{Client API}
Kelas-kelas yang ada pada \textit{Client API} digunakan untuk menangani proses-proses yang terjadi pada bagian \textit{client}. 

Kelas-kelas yang ada pada \textit{Client API} yaitu: 

\subsubsection{Manager}
Kelas ini memiliki \textit{constructor} sebagai berikut: 

\begin{lstlisting}
	Manager(url[, options]
\end{lstlisting}


\begin{itemize}
	\item \textbf{url} , merupakan sebuah \textit{string} yang merepresentasikan suatu \textit{url} yang akan dituju.
	\item \textbf{options}, merupakan suatu objek yang dapat berupa : 
		\begin{itemize}
			\item \textbf{path}, merupakan sebuah \textit{string} yang merepresentasikan suatu \textit{path} yang akan dituju dalam bagian \textit{server}.
			\item \textbf{reconnection}, merupakan sebuah \textit{boolean} yang menunjukan apakah dapat melakukan koneksi ulang secara otomatis atau tidak.
			\item \textbf{timeout}, merupakan angka yang menunjukan koneksi sudah mencapai \textit{timeout} sebelum terjadi error pada koneksi.
		\end{itemize}
\end{itemize}

\subsubsection{Socket}
Kelas ini memiliki atribut \textbf{id}, yang merupakan tanda pengenal unik untuk sesi saat ini.

Beberapa \textit{method} yang dimiliki oleh kelas \textit{Socket} yaitu: 

\begin{itemize}
	\item \textbf{socket.open()} \\ Berfungsi untuk membuka suatu koneksi \textit{socket} tertentu.
	\item \textbf{socket.emit(eventName[, ...args][, ack])} \\ Berfungsi untuk mengeluarkan suatu \textit{event} kepada \textit{socket} yang diidentifikasi oleh nama \textit{event} tersebut.
	\item \textbf{socket.close()} \\ Berfungsi untuk menutup koneksi suatu \textit{socket} secara manual. 
\end{itemize}

%--------------------- END OF SOCKET.IO -----------------

\section{Node.js}
\label{sec:Node.js}

\textit{Node.js} adalah \textit{JavaScript runtime} yang dibangun berdasarkan \textit{V8} yang merupakan \textit{JavaScript engine} milik perusahaan \textit{Google} \cite{nodejs}. \textit{Node.js} memiliki model \textit{event-driven}, dan \textit{non-blocking I/O} yang membuat teknologi tersebut efisien dalam implementasinya. Teknologi ini menyediakan beberapa kelas yang berfungsi untuk mengimplementasi fitur-fitur yang dimiliki.

Beberapa kelas yang terdapat pada \textit{Node.js} yaitu sebagai berikut: 

\subsection{Console}
\textit{Console} merupakan perangkat \textit{debugging} yang memiliki persamaan dengan mekanisme \textit{JavaScript} yang disediakan oleh \textit{web browsers}. Kelas ini dapat digunakan untuk membuat \textit{logger} sederhana dengan \textit{output streams} yang dapat dikonfigurasi. Agar dapat menggunakan kelas ini, dapat dilakukan langkah berikut: 

\begin{lstlisting}
	const Console = require('console').Console;
\end{lstlisting}

Salah satu \textit{method} yang dimiliki oleh kelas ini yaitu: 

\begin{itemize}
	\item \textbf{console.log()} \\ Akan mengeluarkan beberapa argumen pada \textit{stdout (standard output)}.
\end{itemize}

Berikut merupakan contoh implementasi dari \textit{method} tersebut:

\begin{lstlisting}
	const count = 5;
	console.log('count: %d', count);
	// Prints: count: 5, to stdout
\end{lstlisting}

\subsection{File System}
Modul ini berfungsi untuk menangani proses pengaturan \textit{file} pada \textit{server}. Untuk dapat menggunakan modul ini diperlukan \textbf{require('fs')} agar dapat mengakses fitur-fitur yang ada.

Salah satu kelas yang terdapat pada \textit{File System} yaitu: 

\subsubsection{fs.WriteStream}
Kelas ini memiliki beberapa \textit{method} sebagai berikut: 

\begin{itemize}
	\item \textbf{fs.appendFile(file, data[, options],callback)} \\ Berfungsi untuk menambahkan suatu data kedalam \textit{file}, dan membuat \textit{file} baru apabila \textit{file} yang dituju belum tersedia.
	\item \textbf{fs.readFile(file[, options], callback)} \\ Berfungsi untuk membaca seluruh konten dari suatu \textit{file}.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//appendFile
	fs.appendFile('message.txt', 'data to append', (err) => {
	if (err) throw err;
	console.log('The "data to append" was appended to file!');
	});
	
	//readFile
	fs.readFile('/etc/passwd', (err, data) => {
	if (err) throw err;
	console.log(data);
	});
\end{lstlisting}

\subsection{HTTP}
\textit{Interfaces} \textit{HTTP} pada \textit{Node.js} digunakan untuk menangani \textit{request} dari protokol \textit{HTTP} yang secara \textit{native} sulit untuk digunakan. \textit{Interface} ini akan menangani protokol \textit{HTTP} dengan tidak melakukan \textit{buffer} pada seluruh \textit{request} atau \textit{responses}.

Berikut akan dijelaskan kelas-kelas yang ada pada \textit{interface} \textit{HTTP}.

\begin{enumerate}
	\item \textbf{http.IncomingMessage} \\ 
	Objek dari kelas ini akan dibuat oleh kelas \textit{http.Server} atau \textit{http.ClientRequest} dan memasukannya sebagai argumen suatu \textit{event} \textit{'request'} dan \textit{'response'}. Objek tersebut dapat digunakan untuk mengakses status \textit{response}, \textit{headers}, dan data. Kelas ini mengimplementasi \textit{interface Readable Stream}, beserta \textit{method, events,} dan properti yang ada didalamnya.
	
	\textbf{Properti:}
	\begin{itemize}
		\item \textbf{message.headers} \\ \textbf{Kembalian:} \textit{headers} milik objek \textit{request/response.}
		\item \textbf{message.rawHeaders} \\ \textbf{Kembalian:} bentuk \textit{raw} dari \textit{headers} milik objek \textit{request/response}.
		\item \textbf{message.statusCode} \\ \textbf{Kembalian:} tiga dijit kode status \textit{HTTP response}. Contoh: 404.
		\item \textbf{message.statusMessage} \\ \textbf{Kembalian:} pesan status \textit{HTTP response} Contoh: \textit{OK} atau \textit{Internal Server Error.}
		\item \textbf{message.url} \\ \textbf{Kembalian:} \textit{URL string} yang muncul pada permintaan \textit{HTTP}.
	\end{itemize}

	\item \textbf{http.ClientRequest} \\ 
	Objek dari kelas ini dibuat dalam kelas ini sendiri dan dikembalikan dari \textit{method http.request()}. Objek ini merepresentasikan permintaan yang sedang berlangsung dimana \textit{header} objek tersebut sudah berada dalam antrian. \textit{Header} masih dapat diubah dengan menggunakan \textit{setHeader(name, value)} dan \textit{removeHeader(name)}. \textit{Header} yang asli akan dikirim bersamaan dengan \textit{chunk} pertama dari suatu data atau saat memanggil \textit{request.end()}.
	
	Beberapa \textbf{event} yang dimiliki oleh kelas ini yaitu sebagai berikut:
		\begin{itemize}
			\item \textbf{'connect'} \\ Dipancarkan saat \textit{server} merespon kepada permintaan.
			\item \textbf{'response'} \\ Dipancarkan saat suatu respon diterima atas permintaan saat ini.
			\item \textbf{'timeout'} \\ Dipancarkan saat suatu \textit{socket} telah mencapai batas waktu untuk tidak aktif.
		\end{itemize}

	Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu sebagai berikut:
		\begin{itemize}
			\item \textbf{request.end([data[,encoding]][,callback])} \\ 
			\textbf{Parameter:} 
			\begin{itemize}
				\item \textbf{data} \\tipe: \textbf{string} atau \textbf{Buffer} \\ Data yang akan dikirim.
				\item \textbf{encoding} \\tipe: \textbf{string} \\ Bersifat opsional dan akan bernilai \textit{utf8} apabila tipe parameter \textit{data} berupa \textit{string}.
				\item \textbf{callback} \\tipe:	\textbf{Function} \\ Fungsi callback
			\end{itemize}
		
			\textit{Method} ini akan mengakhiri proses pengiriman permintaan.
			
			\item \textbf{request.getHeader(name)} \\
			\textbf{Parameter:} 
			\begin{itemize}
				\item \textbf{name} \\tipe: \textbf{string} \\ Nama dari \textit{header} yang dibutuhkan.
			\end{itemize}
			\textbf{Kembalian:} suatu \textit{string} yang sesuai dengan parameter.
			
			\textit{Method} ini akan membaca seluruh \textit{header} dalam permintaan dan mengembalikan bagian yang sesuai dengan parameter. Berikut contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
	const contentType = request.getHeader('Content-Type');
	\end{lstlisting}
			
			\item \textbf{request.removeHeader(name)} \\ 
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{name} \\tipe: \textbf{string} \\ Nama dari \textit{header} yang dibutuhkan.
			\end{itemize}
			\textit{Method} ini akan menghapus \textit{header} yang sudah ada pada objek \textit{header}. Berikut contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
	request.removeHeader('Content-Type');
	\end{lstlisting}
	
			\item \textbf{request.setHeader(name, value)} \\ 
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{name} \\tipe: \textbf{string} \\ Nama dari \textit{header} yang dibutuhkan.
				\item \textbf{value} \\tipe: \textbf{value} \\ Nilai yang akan dimasukan pada objek \textit{header}
			\end{itemize}
		
			\textit{Method} ini akan menetapkan suatu nilai kepada objek \textit{header}. Berikut contoh implementasi \textit{method} ini:
	\begin{lstlisting}
	request.setHeader('Content-Type', 'application/json');
	\end{lstlisting}
		\end{itemize}

	\item \textbf{http.Server} \\ 
	Kelas ini merupakan turunan dari \textit{net.Server}. \textit{Event} yang dimiliki kelas ini yaitu sebagai berikut:
	\begin{itemize}
		\item \textbf{'close'} \\ Dipancarkan apabila \textit{server} sudah ditutup.
		
	\end{itemize}

	Beberapa properti yang dimiliki oleh kelas ini yaitu:
	\begin{itemize}
		\item \textbf{server.listening} \\ Mengembalikan \textit{boolean} yang menandakan apakah \textit{server} melakukan proses \textit{listening} untuk suatu koneksi atau tidak.
		
		\item \textbf{server.maxHeadersCount} \\ Mengembalikan \textit{number} yang menandakan batas maksimum suatu \textit{headers} yang masuk. Nilai default dari properti ini yaitu 2000.
		
		\item \textbf{server.timeout} \\ Mengembalikan \textit{number} yang menandakan \textit{timeout} dalam milidetik.
	\end{itemize}
	
	Beberapa \textit{Method} yang dimiliki oleh kelas ini yaitu:
	\begin{itemize}
		\item \textbf{server.listen()} \\ Memulai \textit{server HTTP} melakukan proses \textit{listening} untuk suatu koneksi.
		
		\item \textbf{server.setTimeout([msecs][,callback])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{msec} nilai \textit{timeout} dalam milidetik. secara default bernilai 120000 (2 menit).
			\item \textbf{callback} fungsi \textit{callback}.
		\end{itemize}
		\textbf{Kembalian:} objek \textit{server}.
	
		\textit{Method} ini menetapkan nilai \textit{timeout} untuk \textit{sockets} dan memancarkan \textit{event 'timeout'} pada objek \textit{Server}.
		
		\item \textbf{server.close([callback])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{callback} fungsi \textit{callback}.
		\end{itemize} 
		
		\textit{Method} ini menghentikan \textit{server} untuk menerima koneksi baru.
	\end{itemize}
\end{enumerate} 

Beberapa \textit{Method} yang dimiliki oleh \textit{HTTP} yaitu sebagai berikut:
\begin{itemize}
	\item \textbf{http.createServer([requestListener])} \\ \textbf{Parameter:}
	\begin{itemize}
		\item \textbf{requestListener} fungsi yang akan secara otomatis ditambahkan pada \textit{event} \textit{'request'} milik kelas \textit{http.Server}.
	\end{itemize}
	\textbf{Kembalian:} objek \textit{http.Server}
	
	\textit{Method} ini akan membuat objek \textit{http.Server} untuk menangani \textit{request} dari \textit{client} dan memberikan \textit{response} kepada \textit{client}. Fungsi yang diberikan pada \textit{method} ini akan dipanggil satu kali setiap \textit{request} dibuat kepada \textit{server}.
	
	\item \textbf{http.request(options[,callback])} \\ 
	\textbf{Parameter:}
	\begin{itemize}
		\item \textbf{options} \\ Dapat berupa \textit{Object, string} atau \textit{URL}. Berikut jenis-jenis \textit{options} yang dapat menjadi parameter:
		\begin{itemize}
			\item \textbf{protocol} \\tipe: \textbf{string} \\ Protokol yang digunakan.
			\item \textbf{host} \\tipe: \textbf{string} \\ Nama domain atau alamat \textit{IP} milik server.
			\item \textbf{hostname} \\tipe: \textbf{string} \\ Nama lain untuk \textit{host}.
			\item \textbf{port} \\tipe: \textbf{number} \\ \textit{Port} untuk \textit{server}.
			\item \textbf{path} \\tipe: \textbf{string} \\ \textit{Path} untuk permintaan.
			\item \textbf{headers} \\tipe: \textbf{Object} \\ Objek yang berisi permintaan \textit{headers}.
			\item \textbf{timeout} \\tipe: \textbf{number} \\ Nomor yang menentukan \textit{timeout} dari suatu \textit{socket} dalam milidetik.
		\end{itemize}
	
		\item \textbf{callback} \\tipe: \textbf{Function} \\ Fungsi \textit{callback}.
	\end{itemize}

	\textbf{Kembalian:} objek dari kelas \textit{http.ClientRequest}.
	
	\textit{Method} ini digunakan untuk menangani permintaan \textit{HTTP} pada \textit{server}. Berikut contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
	const options = {
		hostname: 'www.google.com',
		port: 80,
		path: '/upload',
		method: 'POST',
		headers: {
		'Content-Type': 'application/x-www-form-urlencoded',
		'Content-Length': Buffer.byteLength(postData)
		}
	};
	
	const req = http.request(options, (res) => {
		console.log(`STATUS: ${res.statusCode}`);
		console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
		res.setEncoding('utf8');
		res.on('data', (chunk) => {
		console.log(`BODY: ${chunk}`);
		});
		res.on('end', () => {
		console.log('No more data in response.');
		});
	});
	
	req.end();
	\end{lstlisting}
	
\end{itemize}

\subsection{Events}
\textit{Node.js} dibangun berdasarkan arsitektur \textit{event-driven} dengan sifat \textit{asynchronous}, dimana jenis-jenis objek tertentu akan memancarkan suatu \textit{events} secara berkala dan akan memanggil objek \textit{Function} ("\textit{listeners}").

Semua objek yang memancarkan \textit{events} merupakan turunan dari kelas \textit{EventEmitter}. Objek tersebut akan memanggil \textit{method} \textit{eventEmitter.on()} yang memungkinkan satu atau beberapa fungsi dapat ditangani dalam suatu \textit{event} yang dipancarkan oleh objek saat ini.

Kelas \textit{EventEmitter} dapat didefinisikan dengan memanggil modul \textit{events} seperti berikut :

\begin{lstlisting}
	const EventEmitter = require('events');
\end{lstlisting}

Sebuah \textit{EventEmitter} akan memancarkan \textit{'event'} \textit{'newListener'} pada saat \textit{listeners} baru akan ditambahkan, dan \textit{'removeListener'} akan dipancarkan saat \textit{listeners} saat ini akan dihapus.

Berikut merupakan beberapa \textit{method} yang dimiliki oleh kelas \textit{EventEmitter}:

\begin{itemize}
	\item \textbf{eventEmitter.on(eventName, listener)} \\ \textbf{Parameter:}
	\begin{itemize}
		\item \textit{eventName}, nama dari suatu \textit{event} yang akan dipancarkan.
		\item \textit{listener}, suatu fungsi \textit{callback} yang akan menangani \textit{event} dari \textit{eventName}. 
	\end{itemize} 
	\textbf{Kembalian:} referensi kepada \textit{EventEmitter}.

	\textit{Method} ini berfungsi untuk mencatat suatu listener yang akan digunakan. Fungsi \textit{listener} yang menjadi parameter \textit{method} ini akan ditambahkan ke \textit{index} terakhir dari \textit{array of listeners} pada \textit{eventName}. Tidak akan ada pengecekan apakah fungsi \textit{listener} sudah dimasukan sebelumnya. Oleh karena itu, pemanggilan \textit{eventName} dan \textit{listener} secara berulang akan menyebabkan fungsi \textit{listener} dimasukan kedalam \textit{array} dan dipanggil secara berulang. \textit{Method} ini juga akan mengembalikan \textit{reference} kepada \textit{EventEmitter}, sehingga pemanggilan dapat saling menyambung dengan pemanggilan lainnya.
	
	Berikut merupakan contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
		const EventEmitter = require('events');
		
		class MyEmmit extends EventEmitter {}
		
		const myEmmit = new MyEmitter();
		
		myEmmit.on('event', () => {
			console.log('suatu event telah terjadi');	
		});
	\end{lstlisting}
	
	\item \textbf{eventEmitter.emit(eventName)} \\ \textit{Method} ini berfungsi untuk memicu suatu \textit{event} yang akan dipancarkan. \textbf{Parameter:}
	\begin{itemize}
		\item \textit{eventName}, nama dari sebuah \textit{event} yang akan dipancarkan.
		\item \textit{...args}, argumen tambahan yang akan diberikan pada \textit{eventName}. 
	\end{itemize}
	\textbf{Kembalian:} \textit{true} apabila \textit{event} memiliki \textit{listener}, false jika tidak.

	\textit{Method} ini akan memanggil masing-masing \textit{listener} yang sudah dicatat oleh \textit{eventEmitter.on()} dalam \textit{array of listeners} secara sinkronis, dimana beberapa \textit{listener} tersebut mengacu pada \textit{eventName} yang sama. Argumen yang diterima dari parameter akan diberikan pada masing-masing \textit{listener}.
	
	Berikut merupakan contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
		const EventEmitter = require('events');
		
		class MyEmmit extends EventEmitter {}
		
		const myEmmit = new MyEmitter();
		
		myEmmit.on('event', () => {
		console.log('suatu event telah terjadi');	
		});
		myEmitter.emit('event');
	\end{lstlisting} 
\end{itemize}

\subsection{Stream}
Kelas ini digunakan untuk menangani aliran data yang terjadi pada \textit{Node.js}. Data yang ditangani dapat berjumlah banyak dan akan menghabiskan banyak memori apabila tidak ditangani dengan baik. Oleh karena itu, modul \textit{stream} menyediakan fitur-fitur yang memudahkan penanganan aliran data.

Ada empat tipe dasar \textit{stream} dalam \textit{Node.js}:
\begin{itemize}
	\item \textbf{Readable} \\ \textit{Streams} yang dapat membaca data dari sumber eksternal tertentu.
	\item \textbf{Writable} \\ \textit{Streams} yang dapat menulis data dan mengirimkannya ke sumber external tertentu.
	\item \textbf{Duplex} \\ \textit{Streams} yang dapat membaca dan menulis data sekaligus.
	\item \textbf{Transform} \\ \textit{Duplex streams} yang dapat memodifikasi atau mengubah data dimana data tersebut dapat dilihat langsung hasil perubahannya.
\end{itemize}

\begin{enumerate}
	\item \textbf{Readable Stream} \\
	Merupakan abstraksi untuk sumber data yang digunakan. Berikut merupakan contoh dari \textit{Readable Stream} pada \textit{Node.js}:
	\begin{itemize}
		\item \textbf{HTTP responses} pada \textit{client}
		\item \textbf{HTTP requests} pada \textit{server}
		\item \textbf{fs read streams}
	\end{itemize}
	Seluruh \textit{Readable streams} mengimplementasi \textit{interface} yang didefinisikan oleh kelas \textit{stream.Readable}.
	
	\begin{itemize}
		\item \textbf{stream.Readable} \\
		\textbf{Events:}
			\begin{itemize}
				\item \textbf{'close'} \\ \textit{Event} ini dipancarkan saat suatu \textit{stream} atau sumber lain telah ditutup. \textit{Event} ini menandakan tidak akan ada \textit{event} lagi yang akan dipancarkan, dan tidak ada komputasi lain yang akan dilakukan.
	\begin{lstlisting}
	const readable = getReadableStreamSomehow();
	readable.on('close', (chunk) => {
		console.log(`Stream telah ditutup`);
	});
	\end{lstlisting}
	
				\item \textbf{'data'} \\ \textit{Event} ini akan dipancarkan setiap kali suatu \textit{stream} melepas kepemilikan sebuah data kepada pemakai. Hal tersebut dapat terjadi setiap suatu \textit{stream} berganti menjadi mode \textit{flowing} dengan memanggil \textit{readable.pipe()}, \textit{readable.resume()}, atau dengan menghubungkan \textit{listener callback} pada \textit{'data' event}. Contoh implementasi:
	\begin{lstlisting}
	const readable = getReadableStreamSomehow();
	readable.on('data', (chunk) => {
		console.log(`Menerima data sebesar ${chunk.length} bytes.`);
	});
	\end{lstlisting}
				
				\item \textbf{'end'} \\ \textit{Event} ini dipancarkan saat tidak ada lagi data yang akan digunakan dari \textit{stream}. Contoh implementasi:
	\begin{lstlisting}
	const readable = getReadableStreamSomehow();
	readable.on('end', () => {
		console.log('Tidak akan ada data yang dikirimkan.');
	});
	\end{lstlisting}
	
				\item \textbf{'error'} \\ \textit{Event} ini akan dipancarkan oleh \textit{Readable} setiap saat. \textit{Event} ini dapat terjadi apabila \textit{stream} tidak dapat menyediakan data dikarenakan kesalahan internal, atau ketika implementasi suatu \textit{stream} mencoba mengirimkan \textit{chunk} dari data yang tidak sesuai. Contoh implementasi:
	\begin{lstlisting}
	const readable = getReadableStreamSomehow();
	readable.on('error', () => {
		console.error('Terjadi kesalahan');
	});
	\end{lstlisting}
	
				
			\end{itemize}
		
		\textbf{Method:}
			\begin{itemize}
				\item \textbf{readable.pipe(destination[, options])} \\ \textbf{Parameter:}
				\begin{itemize}
					\item \textbf{destination} \\tipe: \textit{stream.Writable} \\ Destinasi untuk menulis suatu data.
					\item \textbf{options} \\tipe: \textit{Object} \\ Bersifat opsional, dapat berupa objek sebagai berikut:
					\begin{itemize}
						\item \textbf{end} \\tipe: \textit{boolean} \\ Mengakhiri \textit{writer} yang melakukan proses menulis saat \textit{reader} telah selesai. Nilai \textit{default} parameter ini yaitu \textit{true}.
					\end{itemize}
				\end{itemize}
				\textbf{Kembalian:} referensi yang menuju \textit{destination}.
				
				\textit{Method} ini akan menghubungkan \textit{Writable stream} pada objek \textit{readable}, sehingga dapat berubah menjadi mode \textit{flowing} secara otomatis dan akan menaruh seluruh data pada \textit{Writable} yang sudah terhubung. \textit{Method} ini mengembalikan referensi yang menuju \textit{destination}, sehingga \textit{pipe streams} dapat saling menyambung dengan \textit{pipe streams} lainnya.
				
				Berikut merupakan contoh implementasi dari \textit{method} ini:
				\begin{lstlisting}
					const fs = require('fs');
					
					const readable = getReadableStreamSomehow();
					const writable = fs.createWriteStream('file.txt');
					
					//seluruh data dari objek readable masuk ke 'file.txt'
					readable.pipe(writable); 
				\end{lstlisting}
				
			\end{itemize}
	\end{itemize}
\end{enumerate}


%------------- END OF NODE.JS -------------- 
\section{Express.js}
\label{sec:Express.js}

\textit{Express.js} merupakan \textit{framework} aplikasi web untuk \textit{Node.js} \cite{expressjs}. \textit{Express.js} menyediakan fitur-fitur untuk web dan aplikasi \textit{mobile} agar dapat bertahan lama. Untuk dapat menggunakan \textit{Express.js}, dapat dilakukan langkah sebagai berikut: 
\begin{lstlisting}
	var express = require('express');
	var app = express();
\end{lstlisting}

Dengan begitu, fitur-fitur yang terdapat pada \textit{Express.js} dapat digunakan untuk pengembangan aplikasi tertentu.

subbab-subbab berikut akan menjelaskan kelas-kelas yang terdapat pada \textit{Express.js}.

\subsection{express()}
Untuk membuat aplikasi \textit{Express}, langkah yang dilakukan adalah sebagai berikut:
\begin{lstlisting}
	const express = require('express');
	const app = express();
\end{lstlisting}

\textit{Method} yang dimiliki oleh fungsi \textit{express()} yaitu sebagai berikut:

\begin{itemize}
	\item \textbf{express.Router([options])} \\ \textbf{Parameter:} 
	\begin{itemize}
		\item \textbf{options} bersifat opsional dan akan menentukan sifat dari objek \textit{router}. Parameter ini dapat berupa beberapa jenis seperti berikut:
		\begin{itemize}
			\item \textit{caseSensitive} memungkinkan \textit{case-sensitive}. Dapat bernilai \textit{true} atau \textit{false}. Secara default akan bernilai \textit{false}.
			
			\item \textit{strict} memungkinkan \textit{strict routing}. Dapat bernilai \textit{true} atau \textit{false}. Apabila bernilai \textit{false}, maka parameter \textit{'/foo'} dan \textit{'/foo/'} akan dianggap sama oleh \textit{router}.
		\end{itemize}
	\end{itemize}
	
\end{itemize}

\subsection{Application}
Kelas ini akan menangani berbagai proses yang terjadi dalam aplikasi \textit{Express} seperti melakukan \textit{routing} terhadap \textit{HTTP requests}, mengatur \textit{middleware}, \textit{rendering} sebuah \textit{HTML views}, dan mendaftarkan \textit{template engine} tertentu. Untuk dapat melakukan fungsi-fungsi tersebut dapat dilakukan langkah berikut:

\begin{lstlisting}
	const express = require('express');
	const app = express();
\end{lstlisting}

Baris pertama dari potongan kode tersebut berarti variabel \textit{express} memanggil modul \textit{'express'} agar dapat mengakses fungsi-fungsi yang ada pada modul tersebut. Sedangkan baris kedua, Objek \textit{app} memanggil fungsi \textit{express()} yang telah didapatkan dari variabel \textit{express}.

Kelas ini memiliki beberapa \textit{method} sebagai berikut:

\begin{itemize}
	\item \textbf{app.all(path, callback[, callback ...])} \\ \textbf{Parameter:} 
		\begin{itemize}
			\item \textbf{path} suatu \textit{path} yang akan ditangani oleh \textit{middleware}. Dapat berupa \textit{string}, \textit{path pattern}, atau \textit{array} dari kombinasi \textit{string} dan \textit{path pattern}.
			
			\item \textbf{callback} merupakan fungsi \textit{callback}, dimana fungsi tersebut dapat berupa fungsi \textit{middleware}, kumpulan dari fungsi \textit{middleware} (yang dipisahkan dengan menggunakan koma), fungsi \textit{array of middleware}, atau kombinasi dari seluruh \textit{item} tersebut.
		\end{itemize}
	
		\textit{Method} ini dapat menangani seluruh \textit{HTTP requests} seperti \textit{GET, POST, PUT,} dan \textit{DELETE}. Berikut merupakan contoh implementasi dari \textit{method} ini:
		\begin{lstlisting}
			app.all('/about', function(req, res, next){
				console.log('Mengakses bagian about ...');
				next(); //bagian ini akan menuju ke handler berikutnya
			});
		\end{lstlisting}
	
	\item \textbf{app.get(path, callback[, callback ...])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{path} suatu \textit{path} yang akan ditangani oleh \textit{middleware}. Dapat berupa \textit{string}, \textit{path pattern}, atau \textit{array} dari kombinasi \textit{string} dan \textit{path pattern}.
			
			\item \textbf{callback} merupakan fungsi \textit{callback}, dimana fungsi tersebut dapat berupa fungsi \textit{middleware}, kumpulan dari fungsi \textit{middleware} (yang dipisahkan dengan menggunakan koma), fungsi \textit{array of middleware}, atau kombinasi dari seluruh \textit{item} tersebut.
		\end{itemize}
		
		\textit{Method} ini akan mengarahkan \textit{HTTP GET requests} pada \textit{path} dengan fungsi \textit{callback} tertentu. Berikut merupakan contoh implementasi dari \textit{method} ini:
		\begin{lstlisting}
			app.get('/', function(req, res){
				res.send('Mengirimkan GET request pada homepage');
			});
		\end{lstlisting}
		
	\item \textbf{app.post(path, callback[, callback ...])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{path} suatu \textit{path} yang akan ditangani oleh \textit{middleware}. Dapat berupa \textit{string}, \textit{path pattern}, atau \textit{array} dari kombinasi \textit{string} dan \textit{path pattern}.
			
			\item \textbf{callback} merupakan fungsi \textit{callback}, dimana fungsi tersebut dapat berupa fungsi \textit{middleware}, kumpulan dari fungsi \textit{middleware} (yang dipisahkan dengan menggunakan koma), fungsi \textit{array of middleware}, atau kombinasi dari seluruh \textit{item} tersebut.
		\end{itemize}
	
		\textit{Method} ini akan mengarahkan \textit{HTTP POST requests} pada \textit{path} dengan fungsi \textit{callback} tertentu. Berikut merupakan contoh implementasi dari \textit{method} ini:
		\begin{lstlisting}
			app.post('/', function(req, res){
				res.send('Mengirimkan POST requests pada homepage');
			});
		\end{lstlisting}
		
	\item \textbf{app.route(path)} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{path} suatu \textit{path} yang akan ditangani oleh \textit{middleware}. Dapat berupa \textit{string}, \textit{path pattern}, atau \textit{array} dari kombinasi \textit{string} dan \textit{path pattern}.
		\end{itemize}
		
		\textit{Method} ini akan mengembalikan instansi dari satu \textit{route}, yang kemudian dapat digunakan untuk menangani \textit{HTTP request} dengan \textit{middleware} tertentu. Berikut merupakan contoh implementasi dari \textit{method} ini:
		\begin{lstlisting}
			app.route('/buku').get(function(req, res){
				res.send('Mendapatkan suatu buku');
			});
		\end{lstlisting}
		
	\item \textbf{app.use([path,] callback[, callback...])} \\ \textbf{Parameter:} 
		\begin{itemize}
			\item \textbf{path} suatu \textit{path} yang akan ditangani oleh \textit{middleware}. Dapat berupa \textit{string}, \textit{path pattern}, atau \textit{array} dari kombinasi \textit{string} dan \textit{path pattern}.
			
			\item \textbf{callback} merupakan fungsi \textit{callback}, dimana fungsi tersebut dapat berupa fungsi \textit{middleware}, kumpulan dari fungsi \textit{middleware} (yang dipisahkan dengan menggunakan koma), fungsi \textit{array of middleware}, atau kombinasi dari seluruh \textit{item} tersebut.
		\end{itemize}
	
		\textit{Method} ini akan menghubungkan \textit{middleware} atau suatu fungsi tertentu dengan \textit{path} yang sudah ditentukan. Dalam implementasi \textit{method} ini, urutan penempatan pada baris kode sangat berpengaruh. Setelah \textit{app.use()} dieksekusi, maka suatu \textit{request} tidak akan mengeksekusi \textit{middleware} yang ada dibawah baris kode \textit{app.use()}.  Berikut merupakan contoh implementasi dari \textit{method} ini:
		\begin{lstlisting}
			//request hanya akan sampai pada middleware ini
			app.use(function(req, res){
				res.send('Hanya sampai sini saja');
			});
			
			//request tidak akan mengeksekusi baris ini
			app.get('/', function(req, res){
				res.send('Hello World!');
			});
		\end{lstlisting}
		
	\item \textbf{app.listen(port, [hostname], [backlog], [callback])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{port} nomor yang akan dituju oleh server.
			\item \textbf{hostname} \textit{string} yang diberikan pada gawai tertentu agar dapat dikenali. Parameter ini bersifat opsional.
			\item \textbf{backlog} nomor yang menentukan ukuran maksimal dalam antrian koneksi yang tertunda.Parameter ini bersifat opsional.
			\item \textbf{callback} merupakan fungsi \textit{callback}, dimana fungsi tersebut dapat berupa fungsi \textit{middleware}, kumpulan dari fungsi \textit{middleware} (yang dipisahkan dengan menggunakan koma), fungsi \textit{array of middleware}, atau kombinasi dari seluruh \textit{item} tersebut. Parameter ini bersifat opsional.
		\end{itemize}
	
		\textit{Method} ini akan menghubungkan suatu koneksi pada \textit{host} dan \textit{port} yang sudah ditentukan. Berikut merupakan contoh implementasi dari \textit{method} ini:
		\begin{lstlisting}
			const express = require('express');
			const app = express();
			app.listen(3000);
		\end{lstlisting}
		
\end{itemize}

\subsection{Request}
Sebuah objek dari kelas \textit{Request} akan merepresentasikan \textit{HTTP request} dan memiliki properti untuk \textit{request query} seperti \textit{body, HTTP headers} dan \textit{parameters}.

Beberapa \textit{method} yang ada pada kelas \textit{Request} yaitu: 
\begin{itemize}
	\item \textbf{req.accepts(types)} \\ Berfungsi untuk memeriksa apakah tipe konten tertentu dapat diterima atau tidak.
	
	\item \textbf{req.get(field)} \\ Berfungsi untuk mengembalikan \textit{HTTP request header} tertentu.
	
	\item \textbf{req.is(type)} \\ Berfungsi untuk mengembalikan apakah benar atau salah \textit{type} pada parameter sama dengan status \textit{Content-Type} pada \textit{HTTP header}.
\end{itemize}

\subsection{Response}
Sebuah objek dari kelas \textit{Response} akan merepresentasikan respon \textit{HTTP} yang dikirim oleh \textit{Express} pada saat menerima \textit{HTTP request}.

Beberapa \textit{method} yang terdapat pada kelas \textit{Response} yaitu: 

\begin{itemize}
	\item \textbf{res.send([body])} \\ \textbf{Parameter:} \textit{body} dapat berupa berbagai jenis objek seperti \textit{Buffer}, \textit{String}, dan \textit{Array}.
	
	\textit{Method} ini akan mengirimkan respon HTTP kepada \textit{client} sesuai dengan parameter yang diterima. Berikut merupakan contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
		//parameter objek String
		res.send('Hello World!');
		
		//parameter objek Array
		res.send([1,2,3]);
		
		//parameter objek Buffer
		res.send(new Buffer('<p>This is a Buffer</p>'));
	\end{lstlisting}
	
	\item \textbf{res.end([data][, encoding])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{data} dapat berupa objek \textit{String} atau \textit{Buffer} yang akan dikirim saat mengakhiri proses respon.
			\item \textbf{encoding} merubah suatu tipe data menjadi tipe data yang lain. Contoh beberapa tipe data yang tersedia yaitu \textit{utf8, base64, ascii, } dan \textit{hex}.
		\end{itemize}
	
		\textit{Method} ini berfungsi untuk mengakhiri suatu proses respon. Apabila akan mengakhiri suatu respon tanpa memerlukan suatu data, maka dapat menggunakan \textit{method} ini. Berikut merupakan contoh implementasi \textit{method} ini:
		\begin{lstlisting}
			app.get('/', function(req, res){
				res.end(); //apabila tidak memerlukan data.
				
				res.end('goodbye!'); // apabila memerlukan suatu data untuk mengakhiri proses.
			});
		\end{lstlisting}
	
	\item \textbf{res.render(view[, locals][, callback])} \\ \textbf{Parameter:}
		\begin{itemize}
			\item \textbf{view} suatu \textit{string} yang menunjukan \textit{path} dari suatu \textit{view file}.
			\item \textbf{locals} suatu objek yang memiliki properti yang menunjukan variabel lokal dari \textit{view}.
			\item \textbf{callback} suatu fungsi \textit{callback}. 
		\end{itemize}
	
		\textit{Method} ini berfungsi untuk merubah \textit{view file} dan mengirim \textit{file} tersebut kepada \textit{client}. Berikut merupakan contoh implementasi \textit{method} ini:
		\begin{lstlisting}
			app.get('/', function(req, res){
				res.render('about');  //akan merubah(render) halaman about 
			});
		\end{lstlisting}
		
	\item \textbf{res.sendStatus(statusCode)} \\ \textbf{Parameter:} 
	\begin{itemize}
		\item \textbf{statusCode} kode status \textit{HTTP}.
	\end{itemize}

	\textit{Method} ini akan menetapkan kode status \textit{HTTP} di parameter, dan akan mengirimkan bentuk \textit{String} sebagai \textit{body} dari respon. Berikut contoh implementasi \textit{method} ini:
	\begin{lstlisting}
	res.sendStatus(200); // akan mengirimkan 'OK' pada response body.
	res.sendStatus(404); // akan mengirimkan 'Not Found' pada response body.
	res.sendStatus(500); // akan mengirimkan 'Internal Server Error' pada response body.
	\end{lstlisting}
	
	\item \textbf{res.status(code)} \\ \textbf{Parameter:}
	\begin{itemize}
		\item \textbf{code} kode status \textit{HTTP}.
	\end{itemize}

	\textit{Method} ini akan menetapkan kode status \textit{HTTP} untuk respon. Berikut merupakan contoh implementasi \textit{method} ini:
	\begin{lstlisting}
		res.status(403).end();
		res.status(400).send('Bad Request');
	\end{lstlisting}
	
	\item \textbf{res.json([body])} \\ \textbf{Parameter:}
	\begin{itemize}
		\item \textbf{body} dapat berupa tipe \textit{JSON} apapun, seperti \textit{array, String,} dan \textit{Boolean}.
	\end{itemize}

	\textit{Method} ini berfungsi untuk mengirimkan respon \textit{JSON}. Berikut merupakan contoh implementasi \textit{method} ini:
	\begin{lstlisting}
		res.json({ user: 'tobi', age: '27'});
	\end{lstlisting}
	
\end{itemize}

\subsection{Router}
Objek dari kelas \textit{Router} merupakan \textit{instance} dari \textit{middleware} dan \textit{routes}. Setiap aplikasi \textit{Express} memiliki \textit{router} secara \textit{built-in}. 

\textit{Method} yang dimiliki oleh \textit{Router} yaitu sebagai berikut:

\begin{itemize}
	\item \textbf{router.METHOD(path, [callback, ...] callback)} \\ \textbf{Parameter:} \\ 
	\begin{itemize}
		\item \textbf{path} suatu \textit{path} yang akan ditangani oleh \textit{middleware}. Dapat berupa \textit{string}, \textit{path pattern}, atau \textit{array} dari kombinasi \textit{string} dan \textit{path pattern}.
		
		\item \textbf{callback} merupakan fungsi \textit{callback}, dimana fungsi tersebut dapat berupa fungsi \textit{middleware}, kumpulan dari fungsi \textit{middleware} (yang dipisahkan dengan menggunakan koma), fungsi \textit{array of middleware}, atau kombinasi dari seluruh \textit{item} tersebut.
	\end{itemize}

	\textit{Method} ini menyediakan fungsionalitas \textit{routing} dalam aplikasi \textit{Express}, dimana \textit{METHOD} merupakan salah satu \textit{HTTP methods} seperti \textit{GET, PUT, } dan \textit{POST}, dalam huruf kecil. Dengan begitu, \textit{method} ini dapat berupa \textit{router.get(), router.post(),} dan \textit{router.put()}.
	
	Berikut merupakan contoh implementasi dari \textit{method} ini:
	\begin{lstlisting}
		//menggunakan HTTP method GET
		router.get('/', function(req, res){
			res.send('hello world');
		});
		
		//menggunakan HTTP method POST
		router.post('/buku', function(req, res){
			res.send('mendapatkan buku');
		});
	\end{lstlisting}
	
\end{itemize}

%------------- END OF EXPRESS.JS--------------- 

\section{Canvas API}
\label{sec:Canvas API}
 
Canvas API merupakan salah satu elemen \textit{HTML5} yang digunakan untuk membuat gambar grafis dalam aplikasi web \cite{canvas}. Teknologi ini memiliki fitur untuk membuat komposisi foto, membuat animasi, dan membuat \textit{real-time video processiong} atau \textit{rendering}. 

Subbab-subbab berikut menjelaskan tentang beberapa \textit{interface} dari \textit{Canvas}.

\subsection{HTMLCanvasElement}
\textit{Interface} ini menyediakan beberapa properti dan \textit{method} untuk memanipulasi tata letak dan tampilan dari elemen \textit{canvas}.

Beberapa properti yang dimiliki oleh \textit{HTMLCanvasElement} yaitu : 

\begin{itemize}
	\item \textbf{HTMLCanvasElement.height} \\ Merupakan bilangan integer positif yang merepresentasikan tinggi dari atribut \textit{HTML} pada elemen \textit{canvas} yang diinterpretasikan dalam piksel \textit{CSS}. Apabila atribut tidak didefinisikan, atau atribut diisi dengan nilai negatif, maka akan digunakan nilai \textit{default} yaitu 150.
	\item \textbf{HTMLCanvasElement.width} \\ Merupakan bilangan integer positif yang merepresentasikan lebar dari atribut \textit{HTML} pada elemen \textit{canvas} yang diinterpretasikan dalam piksel \textit{CSS}. Apabila atribut tidak didefinisikan, atau atribut diisi dengan nilai negatif, maka akan digunakan nilai \textit{default} yaitu 300.
\end{itemize}

Beberapa \textit{method} yang dimiliki oleh \textit{HTLMCanvasElement} yaitu : 

\begin{itemize}
	\item \textbf{HTMLCanvasElement.getContext()} \\ \textit{Method} ini akan mengembalikan konteks \textit{drawing} pada \textit{canvas}, atau mengembalikan \textit{null} apabila konteks \textit{ID} tidak tersedia. Konteks \textit{drawing} berfungsi untuk dapat menggambar pada \textit{canvas}.
	\item \textbf{HTMLCanvasElemen.toBlob()} \\ \textit{Method} ini akan membuat objek \textit{Blob} yang merepresentasikan gambar yang ada pada \textit{canvas}. 
	
\end{itemize}


\subsection{CanvasRenderingContext2D}
\textit{Interface} ini digunakan untuk menggambar persegi panjang, teks, gambar, dan objek-objek lain kedalam elemen \textit{canvas}. \textit{CanvasRenderingContext2D} menyediakan konteks \textit{2D rendering} untuk suatu elemen \textit{<canvas>}.
Untuk mendapatkan objek dari \textit{interface} ini, harus memanggil \textit{getContext()} didalam elemen \textit{<canvas>}, dengan memberi ''2d'' sebagai argumen. Berikut contoh penggunaannya :

\begin{lstlisting}
	var canvas = document.getElementById('myCanvas');
	var ctx = canvas.getContext('2d');
\end{lstlisting}

\subsubsection{Rectangles}
Ada tiga \textit{method} yang dapat digunakan untuk menggambar bentuk persegi panjang:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.clearRect()} \\ Berfungsi untuk mengatur semua piksel dalam persegi panjang yang didefinisikan dengan titik awal (x,y) dan ukuran (lebar, tinggi) menjadi hitam transparan, dan menghapus semua konten yang telah digambar sebelumnya.
	\item \textbf{CanvasRenderingContext2D.fillRect()} \\ Berfungsi untuk menggambar persegi panjang dengan berisi warna tertentu, pada posisi (x,y) dengan ukuran yang ditentukan dari \textit{width} dan \textit{height}.
	\item \textbf{CanvasRenderingContext2D.strokeRect()} \\ Berfungsi untuk menggambar hanya garis luar dari persegi panjang, pada posisi (x,y) dengan ukuran yang ditentukan dari \textit{width} dan \textit{height}.
\end{itemize}

\subsubsection{Text}
Berikut merupakan beberapa \textit{method} yang digunakan untuk menggambar suatu teks:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.fillText()} \\ Menggambar teks tertentu pada posisi (x,y).
	\item \textbf{CanvasRenderingContext2D.strokeText()} \\ Menggambar garis luar dari suatu teks pada posisi (x,y).
\end{itemize}

\subsubsection{Line Styles}
Berikut merupakan beberapa properti yang digunakan untuk mengatur bagaimana sebuah garis akan digambar:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.lineWidth} \\ Properti yang merepresentasikan tebal dari suatu garis. Nilai \textit{default} dari properti ini yaitu 1.0.
	\item \textbf{CanvasRenderingContext2D.lineCap} \\ Berfungsi untuk menentukan jenis ujung dari suatu garis. Nilai dari properti ini dapat berupa \textit{round}, \textit{square}, atau \textit{butt}. 
\end{itemize}

\subsubsection{Text Styles}
Berikut merupakan beberapa properti yang digunakan untuk mengatur bagaimana suatu teks digambar.

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.font} \\ Berfungsi untuk mengatur jenis \textit{font} yang akan digunakan. Nilai \textit{default} dari properti ini yaitu 10px \textit{sans-serif}.
	\item \textbf{CanvasRenderingContext2D.textAlign} \\ Berfungsi untuk mengatur penjajaran dari suatu teks.
	\item \textbf{CanvasRenderingContext2D.direction} \\  Berfungsi untuk mengatur arah dari teks tertentu. Nilai dari properti ini dapat berupa kiri-ke-kanan, atau kanan-ke-kiri.
\end{itemize}

\subsubsection{Fill and Stroke Styles}
\textit{Fill style} digunakan untuk memanipulasi warna dan \textit{style} pada suatu bentuk, dan \textit{stroke style} digunakan untuk memanipulasi garis luar pada suatu bentuk.

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.fillStyle} \\ Berfungsi untuk memberi warna yang akan digunakan didalam suatu bentuk tertentu.
	\item \textbf{CanvasRenderingContext2D.strokeStyle} \\ Berfungsi untuk memberi warna yang akan digunakan pada garis luar suatu bentuk tertentu.
\end{itemize}

\subsubsection{Gradients and Patterns}

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.createLinearGradient()} \\ Berfungsi untuk membuat \textit{linear gradient} sepanjang garis pada koordinat tertentu.
	\item \textbf{CanvasRenderingContext2D.createRadialGradient()} \\ Berfungsi untuk membuat \textit{radial gradient} pada koordinat tertentu.
	\item \textbf{CanvasRenderingContext2D.createPattern()} \\ Berfungsi untuk membuat pola dengan menggunakan gambar yang sudah didefinisikan sebelumnya.
\end{itemize}

\subsubsection{Paths}
Beberapa \textit{method} berikut ini dapat digunakan untuk memanipulasi \textit{path} dari suatu objek:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.beginPath()} \\ Berfungsi untuk memulai \textit{path} baru dengan mengosongkan daftar dari \textit{sub-paths}.
	\item \textbf{CanvasRenderingContext2D.closePath()} \\ Berfungsi untuk memindahkan posisi ujung \textit{pen} ke titik awal dari \textit{sub-path} saat ini.
	\item \textbf{CanvasRenderingContext2D.moveTo()} \\ Berfungsi untuk memindahkan posisi ujung \textit{pen} saat ini ke koordinat (x,y).
	\item \textbf{CanvasRenderingContext2D.lineTo()} \\ Berfungsi untuk menghubungkan titik terakhir pada \textit{sub-path} ke koordinat (x,y).
	\item \textbf{CanvasRenderingContext2D.arc()} \\ Berfungsi untuk menambahkan garis lengkung ke \textit{path} yang berpusat pada posisi (x,y) dengan radius \textit{r}, dimulai dari \textit{startAngle} dan berakhir pada \textit{endAngle} dengan arah gambar garis lengkung yang didefinisikan oleh \textit{anticlockwise}.
	\item \textbf{CanvasRenderingContext2D.rect()} \\ Berfungsi untuk membuat \textit{path} persegi panjang pada posisi (x,y) dengan ukuran yang didefinisikan oleh \textit{width} dan \textit{height}.
\end{itemize}




