%versi 2 (8-10-2016)
\chapter{Landasan Teori}
\label{chap:teori}

Pada bab ini akan dijelaskan landasan teori mengenai \textit{WebSockets}, \textit{Socket.io}, \textit{Node.js}, \textit{Express.js}, dan \textit{Canvas API}.

\section{WebSockets}
\label{sec:WebSockets} 

\textit{WebSockets} merupakan \textit{Application Programming Interface (API)} yang memiliki kemampuan untuk membuka sesi komunikasi interaktif antara \textit{browser} pengguna dan \textit{server} \cite{websockets}. Dengan \textit{API} ini, pengguna dapat mengirim pesan ke \textit{server} dan menerima respon tanpa harus melakukan \textit{polling} pada \textit{server} terlebih dahulu.

Subbab-subbab berikut menjelaskan kelas-kelas yang ada pada \textit{WebSockets}.

\subsection{WebSocket}
Kelas ini merupakan inti untuk mengakses fungsi yang ada pada \textit{WebSockets}. Sebuah objek \textit{WebSocket} dapat membuat dan mengelola koneksi \textit{WebSocket} ke server, serta dapat mengirim dan menerima data pada koneksi tersebut. 

%Sebuah objek dari kelas \textit{WebSocket} menyediakan \textit{API} untuk membuat dan mengelola koneksi \textit{WebSocket} ke \textit{server}, dan juga untuk mengirim dan menerima data pada koneksi. \textit{Constructor} pada kelas \textit{WebSocket} menerima satu parameter wajib dan satu parameter pilihan. 

Berikut merupakan konstruktor dari kelas \textit{WebSocket}: 
\begin{lstlisting}
	WebSocket WebSocket(in DOMString url, in optional DOMString protocols);
\end{lstlisting}

\begin{itemize}
	\item \textbf{url}, parameter wajib yang menunjukan \textit{URL} mana yang akan direspon oleh \textit{WebSocket server}.
	
	\item \textbf{protocols}, parameter pilihan (tidak harus ada pada parameter) yang dapat berupa satu \textit{string} atau \textit{array of strings}. Parameter \textit{protocols} merepresentasikan nama dari subprotokol yang akan digunakan oleh objek \textit{WebSocket}. Apabila subprotokol tersedia pada parameter, maka \textit{server} akan memeriksa apakah subprotokol tersebut dapat diterima atau tidak. \textit{Server} akan memberikan respon apabila subprotokol dapat diterima, dan akan menghasilkan suatu \textit{error} apabila tidak dapat diterima. Contoh subprotokol yang dapat digunakan yaitu:
	\begin{itemize}
		\item \textbf{chat}
		\item \textbf{superchat}
	\end{itemize}
	
\end{itemize}

Konstruktor dari kelas \textit{WebSocket} dapat menampilkan suatu \textit{exception} seperti berikut:

\begin{lstlisting}
	SECURITY_ERR
\end{lstlisting}

\textit{Exception} tersebut menandakan bahwa \textit{port} yang akan digunakan untuk melakukan koneksi diblokir.

Atribut yang dimiliki oleh kelas \textit{WebSocket} yaitu:

\begin{itemize}
	\item \textbf{binaryType} \\ tipe: \textbf{DOMString} \\ Sebuah \textit{string} yang menandakan tipe dari data biner yang dikirimkan oleh koneksi tertentu. Nilai dari atribut ini dapat berupa \textit{"ArrayBuffer"} apabila objek dari \textit{ArrayBuffer} digunakan.
	
	\item \textbf{bufferedAmount} \\ tipe: \textbf{unsigned long} \\ Jumlah \textit{bytes} dari data yang belum dikirimkan oleh \textit{method} \textbf{send()}. Nilai dari atribut ini akan kembali menjadi nol apabila seluruh data sudah dikirimkan. Apabila koneksi terputus, nilai atribut ini tidak akan kembali menjadi nol dan akan tetap bertambah apabila terus dilakukan pemanggilan pada \textit{method} \textbf{send()}.
	
	\item \textbf{onclose} \\ tipe: \textbf{EventListener} \\ \textit{Event listener} yang dipanggil saat atribut \textit{readyState} dalam koneksi \textit{WebSocket} berubah menjadi \textit{CLOSED}. \textit{Listener} akan menerima objek dari \textit{CloseEvent} dengan nilai \textit{"close"}.
	
	\item \textbf{onerror} \\ tipe: \textbf{EventListener} \\ \textit{Event listener} yang dipanggil saat terjadi \textit{error}. \textit{Event} tersebut akan bernilai \textit{"error"}.
	
	\item \textbf{onmessage} \\ tipe: \textbf{EventListener} \\ \textit{Event listener} yang dipanggil saat atribut \textit{readyState} dalam koneksi \textit{WebSocket} berubah menjadi \textit{OPEN}. Hal tersebut menandakan bahwa koneksi sudah siap untuk mengirim dan menerima data. \textit{Event} tersebut akan bernilai \textit{"open"}.
	
	\item \textbf{protocol} \\ tipe: \textbf{DOMString} \\ \textit{String} yang menandakan sebuah nama dari sub-protokol yang dipilih oleh \textit{server}. Atribut ini akan menjadi salah satu masukan parameter yang dibutuhkan untuk konstruksi kelas \textit{WebSocket}.
	
	\item \textbf{readyState} \\ tipe: \textbf{unsigned short} \\ Menunjukan kondisi koneksi saat ini. Atribut ini memiliki beberapa konstanta yang menunjukan kondisi dari koneksi \textit{WebSocket}. Konstanta tersebut sebagai berikut:
		\begin{itemize}
			\item \textbf{CONNECTING} \\ nilai: 0 \\ Koneksi belum terbuka.
			\item \textbf{OPEN} \\ nilai: 1 \\ Koneksi sudah terbuka dan siap untuk melakukan komunikasi.
			\item \textbf{CLOSING} \\ nilai: 2 \\ Koneksi sedang dalam proses menutup.
			\item \textbf{CLOSED} \\ nilai: 3 \\ Koneksi sudah tertutup atau tidak dapat dibuka.
		\end{itemize}
	
	\item \textbf{url} \\ tipe: \textbf{DOMString} \\ \textit{URL} yang akan dituju oleh objek \textit{WebSocket}. Atribut ini akan menjadi salah satu masukan parameter untuk konstruksi kelas \textit{WebSocket}.
\end{itemize}

Kelas \textit{WebSocket} memiliki dua buah \textit{method}, yaitu:

\begin{itemize}
	\item \textbf{void close(in optional unsigned long code, in optional DOMString reason)} \\ Berfungsi untuk menutup suatu koneksi atau menghentikan proses koneksi. \\ \textbf{Parameter:} 
		\begin{itemize}
			\item \textbf{code} nilai numerik yang menunjukan kode status, yang menjelaskan mengapa suatu koneksi ditutup. Apabila parameter ini tidak tersedia, maka akan diasumsikan dengan nilai \textit{default} yaitu 1000 yang berarti transaksi selesai.
			\item \textbf{reason} \textit{string} yang menjelaskan mengapa suatu koneksi ditutup. 
		\end{itemize}
	\textit{Method} ini dapat melemparkan eksepsi seperti berikut:
		\begin{itemize}
			\item \textbf{INVALID\_ACCESS\_ERR} parameter \textit{code} yang tidak valid.
			\item \textbf{SYNTAX\_ERR} parameter \textit{reason} yang melebihi batas yang telah ditentukan.
		\end{itemize}
	
	\item \textbf{void send(in DOMString data)} \\ Berfungsi untuk mengirimkan data ke \textit{server} melalui koneksi \textit{WebSocket}, dan menambah nilai dari \textit{bufferedAmount} sebanyak jumlah \textit{bytes} yang dibutuhkan untuk menampung data. \\ \textbf{Parameter} \\ Tipe data yang dikirimkan pada parameter dapat berbeda-beda, Beberapa tipe tersebut yaitu sebagai berikut:
	
		\begin{itemize}
			\item \textbf{USVString} sebuah teks \textit{string} yang ditambahkan ke \textit{buffer} dalam format \textit{UTF-8}. Nilai dari \textit{bufferedAmount} akan bertambah sesuai dengan jumlah \textit{bytes} yang dibutuhkan untuk menyimpan \textit{UTF-8 string}.
			
			\item \textbf{ArrayBuffer} data biner yang disimpan pada \textit{fixed-length buffer}, dimana objek dari \textit{ArrayBuffer} dimanipulasi oleh objek \textit{TypedArray}.
		\end{itemize}
	\textit{Method} ini dapat melemparkan eksepsi seperti berikut:
	\begin{itemize}
		\item \textbf{INVALID\_STATE\_ERR} koneksi saat ini tidak terbuka.
		\item \textbf{SYNTAX\_ERR} parameter \textit{data} tidak valid.
	\end{itemize}
\end{itemize}

\subsection{CloseEvent}
Kelas ini akan menangani koneksi \textit{WebSocket} yang ditutup. Objek \textit{CloseEvent} akan dikirim ke \textit{client} saat koneksi ditutup. Objek tersebut akan dikirimkan ke \textit{listener} yang ditunjukan oleh atribut \textit{onclose} milik objek \textit{WebSocket}.

Konstruksi kelas ini yaitu:

\begin{itemize}
	\item \textbf{new CloseEvent(typeArg, closeEventInit);} \\ \textbf{Parameter:} 
		\begin{itemize}
			\item \textbf{typeArg} \\ tipe: \textbf{DOMString} \\ nama dari suatu \textit{event} yang akan dikirimkan.
			\item \textbf{closeEventInit} bersifat pilihan, dan memiliki beberapa nilai sebagai berikut:
				\begin{itemize}
					\item \textit{"wasClean"} \\ tipe: \textbf{boolean} \\ menunjukan apakah koneksi sudah ditutup dengan baik atau belum.
					\item \textit{"code"} \\ tipe: \textbf{unsigned short} \\ kode status yang menunjukan mengapa koneksi ditutup.
					\item \textit{"reason"} \\ tipe: \textbf{DOMString} \\ teks yang menunjukan alasan mengapa koneksi ditutup oleh \textit{server}.
				\end{itemize}
		\end{itemize}
\end{itemize}

Berikut merupakan nilai-nilai dari kode status koneksi ditutup:

\begin{itemize}
	\item \textbf{0-999} \\ nama: - \\ \textit{Reserved}. Tidak digunakan.
	
	\item \textbf{1000} \\ nama: \textbf{Normal Closure} \\ Penutupan normal, yang berarti koneksi sudah menyelesaikan apapun tujuan dari koneksi tersebut.
	
	\item \textbf{1001} \\ nama: \textbf{Going Away} \\ \textit{Endpoint} menghilang karena kesalahan server atau \textit{browser} tidak lagi mengakses halaman yang sudah membuka koneksi.
	
	\item \textbf{1002} \\ nama: \textbf{Protocol Error} \\ \textit{Endpoint} menghentikan koneksi karena adanya kesalahan protokol.
	
	\item \textbf{1003} \\ nama: \textbf{Unsupported Data} \\ Koneksi dihentikan karena \textit{endpoint} menerima data dengan tipe yang tidak bisa diterima (contoh: \textit{text-only endpoint} menerima data biner).
	
	\item \textbf{1004} \\ nama: - \\ \textit{Reserved}. Makna dari kode tersebut akan dijelaskan di waktu yang akan datang.
	
	\item \textbf{1005} \\ nama: \textbf{No Status Recieved} \\ \textit{Reserved}. Menandakan bahwa tidak ada kode status yang tersedia.
	
	\item \textbf{1006} \\ nama: \textbf{Abnormal Closure} \\ \textit{Reserved}. Menandakan bahwa koneksi ditutup secara tidak normal (contoh: tidak ada \textit{close frame} yang dikirimkan).
	
	\item \textbf{1007} \\ nama: \textbf{Invalid frame payload data} \\ \textit{Endpoint} menghentikan koneksi karena pesan yang diterima berisi data yang tidak konsisten (contoh: data \textit{non-UTF-8} berada di dalam pesan teks).
	
	\item \textbf{1008} \\ nama: \textbf{Policy Violation} \\ \textit{Endpoint} menghentikan koneksi karena menerima pesan yang melanggar kebijakan. Kode status ini dapat digunakan apabila tidak ada kode status lain yang cocok atau digunakan untuk tidak menunjukan kebijakan lebih rinci.
	
	\item \textbf{1009} \\ nama: \textbf{Message too big} \\ \textit{Endpoint} menghentikan koneksi karena menerima \textit{frame} data yang terlalu besar.
	
	\item \textbf{1010} \\ nama: \textbf{Missing Extension} \\ \textit{Client} menghentikan koneksi karena \textit{server} tidak menangani satu atau beberapa ekstensi yang diminta oleh \textit{client}.
	
	\item \textbf{1011} \\ nama: \textbf{Internal Error} \\ \textit{Server} menghentikan koneksi karena mengalami kondisi tertentu yang menyebabkan tidak bisa memenuhi permintaan \textit{client}.
	
	\item \textbf{1012} \\ nama: \textbf{Service Restart} \\ \textit{Server} menghentikan koneksi karena harus mengulang kembali koneksi.
	
	\item \textbf{1013} \\ nama: \textbf{Try Again Later} \\ \textit{Server} menghentikan koneksi karena ada kondisi yang harus ditangani untuk sementara (contoh: \textit{overloaded}).
	
	\item \textbf{1014} \\ nama: \textbf{Bad Gateway} \\ \textit{Server} bertindak sebagai \textit{gateway} atau \textit{proxy} dan menerima respon yang tidak benar dari \textit{upstream server}.
	
	\item \textbf{1015} \\ nama: \textbf{TLS Handshake} \\ \textit{Reserved}. Menandakan bahwa koneksi ditutup karena gagal melakukan \textit{TLS handsake} (contoh: sertifikat \textit{server} tidak dapat diverifikasi).
	
	\item \textbf{1016-1999} \\ nama: - \\ \textit{Reserved}. Akan digunakan oleh standar \textit{WebSocket} di waktu yang akan datang.
	
	\item \textbf{2000-2999} \\ nama: - \\ \textit{Reserved}. Akan digunakan oleh ekstensi \textit{WebSocket}.
	
	\item \textbf{3000-3999} \\ nama: - \\ Tersedia untuk digunakan oleh \textit{libraries} dan \textit{frameworks}.
	
	\item \textbf{4000-4999} \\ nama: - \\ Tersedia untuk digunakan oleh aplikasi.
\end{itemize}

\subsection{MessageEvent}
Kelas ini merepresentasikan pesan yang diterima oleh suatu objek tertentu. \textit{Constructor} dari kelas ini yaitu: 

\begin{lstlisting}
	MessageEvent()
\end{lstlisting}

Beberapa properti yang dimiliki oleh kelas ini yaitu: 

\begin{itemize}
	\item \textbf{MessageEvent.data} \\ Merupakan data yang telah dikirimkan oleh pengirim.
	\item \textbf{MessageEvent.lastEventId} \\ Merepresentasikan \textit{ID} yang unik untuk sebuah \textit{Event}.
\end{itemize}

Contoh penggunaan dari beberapa properti tersebut sebagai berikut:

\begin{lstlisting}
	//MessageEvent.data
	myWorker.onmessage = function(e) {
	result.textContent = e.data;
	console.log('Message received from worker');
	};
	
	//MessageEvent.lastEventId
	myWorker.onmessage = function(e) {
	result.textContent = e.data;
	console.log('Message received from worker');
	console.log(e.lastEventId);
	};
\end{lstlisting}


%-------------REVISED LIMIT OF WEBSOCKETS---------

\section{Socket.io}
\label{sec:Socket.io}

\textit{Socket.io} merupakan salah satu teknologi yang memanfaatkan protokol \textit{WebSockets} \cite{socketio}. Teknologi ini memungkinkan sebuah aplikasi untuk melakukan komunikasi dua arah secara \textit{real-time}. \textit{Socket.io} dapat dijalankan di setiap \textit{platform, browser}, dan gawai.

\textit{Socket.io} dibagi menjadi dua \textit{API}, yaitu \textit{Server API} dan \textit{Client API}. Subbab-subbab berikut menjelaskan kelas-kelas yang dimiliki \textit{Socket.io}.

\subsection{Server API}
Kelas-kelas yang ada pada \textit{Server API} digunakan untuk menangani proses yang terjadi dalam \textit{server}\cite{socketioserver}. Kelas-kelas tersebut adalah sebagai berikut:

\begin{enumerate}
	\item \textbf{Server} \\ Kelas ini merupakan inti untuk dapat menangani proses yang terjadi dalam \textit{socket.io server}. Kelas ini memiliki tiga konstruktor seperti berikut: 
	\begin{itemize}
		\item \textbf{new Server(httpServer[, options])} \\ 
		\textbf{Parameter:}
		\begin{itemize}
			\item \textbf{httpServer} \\ tipe: \textbf{http.Server} \\ \textit{Server} yang akan dituju.
			\item \textbf{options} \\ tipe: \textbf{Object} \\ Parameter ini dapat berupa berbagai jenis objek. Objek-objek tersebut yaitu sebagai berikut: 
			\begin{itemize}
				\item \textbf{path} \\ tipe: \textbf{String} \\ Nama dari path yang akan ditangkap oleh \textit{server} (contoh: \textit{/socket.io}).
				
				\item \textbf{serveClient} \\ tipe: \textbf{Boolean} \\ Menunjukan apakah \textit{server} akan melayani \textit{file} dari \textit{client} atau tidak.
				
				%\item \textbf{adapter} \\ tipe: \textbf{Adapter} \\ \textit{Adapter} yang akan digunakan oleh \textit{server}.
				
				%\item \textbf{origins} \\ tipe: \textbf{String} \\ \textit{Origins} yang diperbolehkan oleh \textit{server}.
				
				%\item \textbf{parser} \\ tipe: \textbf{Parser} \\ \textit{Parser} yang akan digunakan oleh \textit{server}.
			\end{itemize}
		\end{itemize}
	
		Untuk dapat menggunakan fitur yang ada pada \textit{socket.io}, harus menambahkan modul \textit{socket.io} pada konstanta tertentu. Hal tersebut dapat dilakukan dengan dua cara, yaitu menggunakan kata kunci \textit{new} atau tanpa menggunakan kata kunci \textit{new}:
		
		\begin{itemize}
			\item Menggunakan \textit{new}
			\begin{lstlisting}
	const Server = require('socket.io');
	const io = new Server();
			\end{lstlisting}
			
			\item Tanpa menggunakan \textit{new}
			\begin{lstlisting}
	const io = require('socket.io')();
			\end{lstlisting}
		\end{itemize}
	
	Contoh implementasi konstruktor:
	
	\begin{lstlisting}
	const Server = require('socket.io');
	const http = require('http').createServer();
		
	const io = new Server(http, {
		path: '/test',
		serveClient: false
	});
	\end{lstlisting}
	
	\item \textbf{new Server(port[,options])} \\
	\textbf{Parameter:}
	\begin{itemize}
		\item \textbf{port} \\ tipe: \textbf{Number} \\ Nomor \textit{port} yang akan dituju.
		\item \textbf{options} \\ tipe: \textbf{Object} \\ Sama seperti konstruktor pertama, parameter ini dapat berupa berbagai jenis objek.
	\end{itemize}
	
	Contoh pemakaian konstruktor: 
	\begin{lstlisting}
	const Server = require('socket.io');
	const io = new Server(3000, {
		path: '/test',
		serveClient: false
	});
	\end{lstlisting}
	
	\item \textbf{new Server(options)} \\ 
	\textbf{Parameter:}
	
		\begin{itemize}
			\item \textbf{options} \\ tipe: \textbf{Object} \\ Sama seperti konstruktor pertama, parameter ini dapat berupa berbagai jenis objek.
		\end{itemize}
	
	Contoh implementasi konstruktor:
	
	\begin{lstlisting}
	const Server = require('socket.io');
	const io = new Server({
		path: '/test',
		serveClient: false
	});
	\end{lstlisting}
	
	\end{itemize}

	Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu sebagai berikut: 
	
		\begin{itemize}
			\item \textbf{server.serveClient([value])} \\ 
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{value} \\ tipe: \textbf{Boolean}
			\end{itemize}
			\textbf{Kembalian:} \textit{Server} atau \textit{Boolean}. \\
			Apabila parameter \textit{value} bernilai \textit{true}, maka \textit{server} akan menangani \textit{file} dari \textit{client}. Apabila tidak ada argumen pada \textit{method} ini, maka kembalian akan berupa status \textit{default} dari \textit{serveClient} saat ini (\textit{true}).
			
			\item \textbf{server.path([value])} \\
			\textbf{Parameter:}
			\begin{itemize}
				\item \textbf{value} \\ tipe: \textbf{String}
			\end{itemize}
			\textbf{Kembalian:} \textit{Server} atau \textit{String} \\
			Parameter \textit{value} akan menunjukan nilai dari \textit{path} yang akan dituju. Secara \textit{default} nilai dari \textit{path} akan diisi dengan \textit{/socket.io}. Apabila tidak ada argumen pada \textit{method} ini, maka kembalian akan berupa nilai dari \textit{value} saat ini.
			
			\item \textbf{server.attach(httpServer[, options])}
			
		
		
			
		\end{itemize}

	\item \textbf{Namespace}
	
	\item \textbf{Socket}
	
	\item \textbf{Client}  
	
\end{enumerate}
	
\subsubsection{Namespace}
Kelas ini merepresentasikan kumpulan dari \textit{sockets} yang terhubung dalam lingkup tertentu, yang diidentifikasi oleh sebuah \textit{pathname}. \textit{Client} selalu terhubung ke \textit{/} (\textit{namespace} utama), kemudian dapat terhubung ke \textit{namespace} lainnya ketika menggunakan koneksi yang sama.

Beberapa properti yang dimiliki oleh kelas ini yaitu: 
\begin{itemize}
	\item \textbf{namespace.name} \\ Sebuah \textit{string} yang merupakan \textit{identifier} pada \textit{namespace}.
	\item \textbf{namespace.connected} \\ Sebuah \textit{hash} dari objek \textit{Socket} yang terhubung pada \textit{namespace} saat ini.
	\item \textbf{namespace.adapter} \\ Sebuah adaptor yang digunakan untuk \textit{namespace} tertentu.
\end{itemize}

Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu:

\begin{itemize}
	\item \textbf{namespace.emit(eventName[, ...args])} \\ Akan menyebarkan suatu \textit{event} ke semua \textit{clients} yang sedang melakukan koneksi.
	
	\item \textbf{namespace.client(callback)} \\ Akan mendapatkan daftar para \textit{clients} yang sedang terkoneksi dengan \textit{namespace} ini.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//namespace.emit
	const io = require('socket.io')();
	io.emit('an event sent to all connected clients');
	
	//namespace.client
	const io = require('socket.io')();
	io.of('/chat').clients((error, clients) => {
	if (error) throw error;
	console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]
	});
\end{lstlisting}

\subsubsection{Socket}
Kelas ini merupakan kelas yang sangat mendasar untuk melakukan interaksi dengan \textit{browser} milik \textit{client}. Sebuah \textit{Socket} dimiliki oleh \textit{Namespace} tertentu (secara \textit{default} menggunakan \textbf{/}).

Beberapa properti yang dimiliki oleh kelas ini yaitu : 
\begin{itemize}
	\item \textbf{socket.id} \\ Merupakan tanda pengenal yang unik untuk sesi tertentu.
	\item \textbf{socket.client} \\ Merupakan \textit{reference} ke objek \textit{Client} tertentu.
	\item \textbf{socket.request} \\ Merupakan \textit{getter proxy} yang mengembalikan referensi ke \textit{request} yang berasal dari \textit{Client} tertentu.
\end{itemize}

Beberapa \textit{method} yang dimiliki oleh kelas ini yaitu : 
\begin{itemize}
	\item \textbf{socket.send([...args[, ack]])} \\ Berfungsi untuk mengirimkan pesan tertentu.
	\item \textbf{socket.emit(eventName[, ...args][, ack])} \\ Berfungsi untuk mengeluarkan suatu \textit{event} kepada \textit{socket} yang diidentifikasi oleh nama \textit{event} tersebut.
	\item \textbf{socket.disconnect(close)} \\ Berfungsi untuk mengakhiri koneksi milik \textit{client} saat ini.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//emit
	socket.emit('hello', 'world');
	
	//disconnect
	io.on('connection', (socket) => {
	setTimeout(() => socket.disconnect(true), 5000);
	});
\end{lstlisting}

\subsubsection{Client}
Kelas ini merepresentasikan koneksi \textit{transport} yang masuk\cite{socketioclient}. \textit{Client} dapat terhubung dengan beberapa \textit{Sockets} yang termasuk dalam \textit{Namespaces} yang berbeda.

Atribut-atribut yang dimiliki oleh kelas ini yaitu: 

\begin{itemize}
	\item \textbf{client.conn} \\ Merupakan referensi kepada koneksi \textit{Socket}.
	\item \textbf{client.request} \\ Berfungsi untuk mengakses \textit{header} dari \textit{request} seperti \textit{Cookie} atau \textit{User-Agent}.
\end{itemize}

\subsection{Client API}
Kelas-kelas yang ada pada \textit{Client API} digunakan untuk menangani proses-proses yang terjadi pada bagian \textit{client}. 

Kelas-kelas yang ada pada \textit{Client API} yaitu: 

\subsubsection{Manager}
Kelas ini memiliki \textit{constructor} sebagai berikut: 

\begin{lstlisting}
	Manager(url[, options]
\end{lstlisting}


\begin{itemize}
	\item \textbf{url} , merupakan sebuah \textit{string} yang merepresentasikan suatu \textit{url} yang akan dituju.
	\item \textbf{options}, merupakan suatu objek yang dapat berupa : 
		\begin{itemize}
			\item \textbf{path}, merupakan sebuah \textit{string} yang merepresentasikan suatu \textit{path} yang akan dituju dalam bagian \textit{server}.
			\item \textbf{reconnection}, merupakan sebuah \textit{boolean} yang menunjukan apakah dapat melakukan koneksi ulang secara otomatis atau tidak.
			\item \textbf{timeout}, merupakan angka yang menunjukan koneksi sudah mencapai \textit{timeout} sebelum terjadi error pada koneksi.
		\end{itemize}
\end{itemize}

\subsubsection{Socket}
Kelas ini memiliki atribut \textbf{id}, yang merupakan tanda pengenal unik untuk sesi saat ini.

Beberapa \textit{method} yang dimiliki oleh kelas \textit{Socket} yaitu: 

\begin{itemize}
	\item \textbf{socket.open()} \\ Berfungsi untuk membuka suatu koneksi \textit{socket} tertentu.
	\item \textbf{socket.emit(eventName[, ...args][, ack])} \\ Berfungsi untuk mengeluarkan suatu \textit{event} kepada \textit{socket} yang diidentifikasi oleh nama \textit{event} tersebut.
	\item \textbf{socket.close()} \\ Berfungsi untuk menutup koneksi suatu \textit{socket} secara manual. 
\end{itemize}

%--------------------- END OF SOCKET.IO -----------------

\section{Node.js}
\label{sec:Node.js}

\textit{Node.js} adalah \textit{JavaScript runtime} yang dibangun berdasarkan \textit{V8} yang merupakan \textit{JavaScript engine} milik perusahaan \textit{Google} \cite{nodejs}. \textit{Node.js} memiliki model \textit{event-driven}, dan \textit{non-blocking I/O} yang membuat teknologi tersebut efisien dalam implementasinya. Teknologi ini menyediakan beberapa modul atau kelas yang berfungsi untuk mengimplementasi fitur-fitur yang dimiliki.

Beberapa kelas yang terdapat pada \textit{Node.js} yaitu sebagai berikut: 

\subsection{Console}
\textit{Console} merupakan perangkat \textit{debugging} yang memiliki persamaan dengan mekanisme \textit{JavaScript} yang disediakan oleh \textit{web browsers}. Kelas ini dapat digunakan untuk membuat \textit{logger} sederhana dengan \textit{output streams} yang dapat dikonfigurasi. Agar dapat menggunakan kelas ini, dapat dilakukan langkah berikut: 

\begin{lstlisting}
	const Console = require('console').Console;
\end{lstlisting}

Salah satu \textit{method} yang dimiliki oleh kelas ini yaitu: 

\begin{itemize}
	\item \textbf{console.log()} \\ Akan mengeluarkan beberapa argumen pada \textit{stdout (standard output)}.
\end{itemize}

Berikut merupakan contoh implementasi dari \textit{method} tersebut:

\begin{lstlisting}
	const count = 5;
	console.log('count: %d', count);
	// Prints: count: 5, to stdout
\end{lstlisting}

\subsection{File System}
Modul ini berfungsi untuk menangani proses pengaturan \textit{file} pada \textit{server}. Untuk dapat menggunakan modul ini diperlukan \textbf{require('fs')} agar dapat mengakses fitur-fitur yang ada.

Salah satu kelas yang terdapat pada \textit{File System} yaitu: 

\subsubsection{fs.WriteStream}
Kelas ini memiliki beberapa \textit{method} sebagai berikut: 

\begin{itemize}
	\item \textbf{fs.appendFile(file, data[, options],callback)} \\ Berfungsi untuk menambahkan suatu data kedalam \textit{file}, dan membuat \textit{file} baru apabila \textit{file} yang dituju belum tersedia.
	\item \textbf{fs.readFile(file[, options], callback)} \\ Berfungsi untuk membaca seluruh konten dari suatu \textit{file}.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//appendFile
	fs.appendFile('message.txt', 'data to append', (err) => {
	if (err) throw err;
	console.log('The "data to append" was appended to file!');
	});
	
	//readFile
	fs.readFile('/etc/passwd', (err, data) => {
	if (err) throw err;
	console.log(data);
	});
\end{lstlisting}

\subsection{HTTP}
\textit{HTTP} dalam \textit{Node.js} berfungsi untuk mendukung berbagai fitur dari protokol tersebut yang sulit untuk digunakan. 

Salah satu kelas yang terdapat pada \textit{HTTP} yaitu: 

\subsubsection{http.Server}
Kelas ini memiliki beberapa \textit{method} sebagai berikut: 

\begin{itemize}
	\item \textbf{server.close([callback])} \\ Berfungsi untuk menghentikan \textit{server} dalam menerima koneksi-koneksi baru.
	\item \textbf{server.listen([port][, hostname][, backlog][, callback])} \\ Berfungsi agar \textit{server} dapat menerima koneksi baru \textit{port} dan \textit{hostname} tertentu.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut: 

\begin{lstlisting}
	//close
	server.close();
	
	//listen
	server.listen(port, hostname, () => {
		console.log('connected');
	});
\end{lstlisting}

\subsection{Events}
\textit{Node.js} dibangun berdasarkan arsitektur \textit{event-driven} dengan sifat \textit{asynchronous}, dimana jenis-jenis objek tertentu akan memancarkan suatu \textit{events} secara berkala dan akan memanggil objek \textit{Function} ("\textit{listeners}").

Semua objek yang memancarkan \textit{events} merupakan turunan dari kelas \textit{EventEmitter}. Objek tersebut akan memanggil \textit{method} \textit{eventEmitter.on()} yang memungkinkan satu atau beberapa fungsi dapat ditangani dalam suatu \textit{event} yang dipancarkan oleh objek saat ini.

Kelas \textit{EventEmitter} dapat didefinisikan dengan memanggil modul \textit{events} seperti berikut :

\begin{lstlisting}
	const EventEmitter = require('events');
\end{lstlisting}

Sebuah \textit{EventEmitter} akan memancarkan \textit{'event'} \textit{'newListener'} pada saat \textit{listeners} baru akan ditambahkan, dan \textit{'removeListener'} akan dipancarkan saat \textit{listeners} saat ini akan dihapus.

Berikut merupakan beberapa \textit{method} yang dimiliki oleh kelas \textit{EventEmitter}:

\begin{itemize}
	\item \textbf{eventEmitter.on(eventName, listener)} \\ \textit{Method} ini berfungsi untuk mencatat suatu listener yang akan digunakan. \textit{Method} ini menerima dua parameter, yaitu:
	\begin{itemize}
		\item \textit{eventName}, nama dari suatu \textit{event} yang akan dipancarkan.
		\item \textit{listener}, suatu fungsi \textit{callback} yang akan menangani \textit{event} dari \textit{eventName}.
	\end{itemize} 
	Fungsi \textit{listener} akan ditambahkan ke \textit{index} terakhir dari \textit{array of listeners} pada \textit{eventName}. Tidak akan ada pengecekan apakah fungsi \textit{listener} sudah dimasukan sebelumnya. Oleh karena itu, pemanggilan \textit{eventName} dan \textit{listener} secara berulang akan menyebabkan fungsi \textit{listener} dimasukan kedalam \textit{array} dan dipanggil secara berulang.
	
	Contoh penggunaan dari method tersebut adalah sebagai berikut:
	\begin{lstlisting}
		server.on('connection', (stream) => {
			console.log('someone connected!');	
		});
	\end{lstlisting}
	
	\textit{Method} ini juga akan mengembalikan \textit{reference} kepada \textit{EventEmitter}, sehingga pemanggilan dapat saling menyambung dengan pemanggilan lainnya.
	
	\item \textbf{eventEmitter.emit(eventName)} \\ \textit{Method} ini berfungsi untuk memicu suatu \textit{event} yang akan dipancarkan. \textit{Method} ini menerima dua parameter, yaitu:
	\begin{itemize}
		\item \textit{eventName}, nama dari sebuah \textit{event} yang akan dipicu.
		\item \textit{...args}, argumen tambahan yang akan diberikan pada \textit{eventName}. 
	\end{itemize}

	\textit{Method} ini akan memanggil masing-masing \textit{listener} yang sudah dicatat oleh \textit{eventEmitter.on()} dalam \textit{array of listeners} secara sinkronis, dimana beberapa \textit{listener} tersebut mengacu pada \textit{eventName} yang sama. Argumen yang diterima dari parameter akan diberikan pada masing-masing \textit{listener}.
	
	Berikut merupakan contoh penggunaan dari \textit{eventEmitter.on()} dan \textit{eventEmitter.emit()}:
	\begin{lstlisting}
		const EventEmitter = require('events');
		
		class MyEmitter extends EventEmitter {}
		
		const myEmitter = new MyEmitter();
		myEmitter.on('event', () => {
		console.log('an event occurred!');
		});
		myEmitter.emit('event');
	\end{lstlisting} 
\end{itemize}



%------------- END OF NODE.JS -------------- 
\section{Express.js}
\label{sec:Express.js}

\textit{Express.js} merupakan \textit{framework} aplikasi web untuk \textit{Node.js} \cite{expressjs}. \textit{Express.js} menyediakan fitur-fitur untuk web dan aplikasi \textit{mobile} agar dapat bertahan lama. Untuk dapat menggunakan \textit{Express.js}, dapat dilakukan langkah sebagai berikut: 
\begin{lstlisting}
	var express = require('express');
	var app = express();
\end{lstlisting}

Dengan begitu, fitur-fitur yang terdapat pada \textit{Express.js} dapat digunakan untuk pengembangan aplikasi tertentu.

subbab-subbab berikut akan menjelaskan kelas-kelas yang terdapat pada \textit{Express.js}.

\subsection{Application}
Sebuah objek dari kelas \textit{Application} akan dapat menangani masalah aplikasi dalam pengembangannya. 

Beberapa \textit{method} yang terdapat pada kelas ini yaitu : 
\begin{itemize}
	\item \textbf{app.get()} \\ Berfungsi untuk mengembalikan nama dari sebuah aplikasi tertentu.
	
	\item \textbf{app.listen(path, [callback])} \\ Berfungsi untuk melakukan koneksi ke suatu \textit{path} yang diberikan.
	
	\item \textbf{app.path()} \\ Berfungsi untuk mengembalikan \textit{path} tertentu yang dituju.
	
	\item \textbf{app.delete(path, callback [, callback ...])} \\ Berfungsi untuk menghapus \textit{request} pada \textit{path} tertentu.
	
	\item \textbf{app.path()} \\ Berfungsi untuk mengembalikan \textit{path} resmi dari sebuah \textit{app} berupa \textit{string}.
	
	
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	var express = require('express');
	var app = express();
	
	app.get('/', function(req, res){
	res.send('hello world');
	});
	
	app.listen(3000);
	
	//delete
	app.delete('/', function (req, res) {
	res.send('DELETE request to homepage');
	});
	
	//path
	console.log(app.path());
	
\end{lstlisting}

\subsection{Request}
Sebuah objek dari kelas \textit{Request} akan merepresentasikan \textit{HTTP request} dan memiliki properti untuk \textit{request query} seperti \textit{body, HTTP headers} dan \textit{parameters}.

Beberapa properti yang ada pada kelas ini yaitu:

\begin{itemize}
	\item \textbf{req.app} \\ Memiliki referensi ke suatu \textit{instance} dari aplikasi yang menggunakan \textit{middleware}.
	
	\item \textbf{req.baseURL} \\ \textit{Path} URL dimana \textit{router} terpasang pada suatu \textit{instance}.
	
	\item \textbf{req.route} \\ Berisi \textit{route} yang cocok saat ini.
	
\end{itemize} 

Berikut merupakan contoh implementasi dari beberapa properti tersebut:

\begin{lstlisting}
	//app
	module.exports = function (req, res) {
	res.send('The views directory is ' + req.app.get('views'));
	});
	
	//baseURL
	var greet = express.Router();
	
	greet.get('/jp', function (req, res) {
	console.log(req.baseUrl); // /greet
	res.send('Konichiwa!');
	});
	
	//route
	app.get('/user/:id?', function userIdHandler(req, res) {
	console.log(req.route);
	res.send('GET');
	});
\end{lstlisting}

Beberapa \textit{method} yang ada pada kelas \textit{Request} yaitu: 
\begin{itemize}
	\item \textbf{req.accepts(types)} \\ Berfungsi untuk memeriksa apakah tipe konten tertentu dapat diterima atau tidak.
	
	\item \textbf{req.get(field)} \\ Berfungsi untuk mengembalikan \textit{HTTP request header} tertentu.
	
	\item \textbf{req.is(type)} \\ Berfungsi untuk mengembalikan apakah benar atau salah \textit{type} pada parameter sama dengan status \textit{Content-Type} pada \textit{HTTP header}.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	// Accept: text/*, application/json
	req.accepts('html');
	// => "html"
	req.accepts('text/html');
	// => "text/html"
	req.accepts(['json', 'text']);
	// => "json"
	req.accepts('application/json');
	// => "application/json"
	
	//get
	req.get('Content-Type');
	// => "text/plain"
	
	//is
	// With Content-Type: text/html; charset=utf-8
	req.is('html');       // => 'html'
	req.is('text/html');  // => 'text/html'
	req.is('text/*');     // => 'text/*'
\end{lstlisting}

\subsection{Response}
Sebuah objek dari kelas \textit{Response} akan merepresentasikan respon \textit{HTTP} yang dikirim oleh \textit{Express} pada saat menerima \textit{HTTP request}.

Beberapa \textit{method} yang terdapat pada kelas \textit{Response} yaitu : 

\begin{itemize}
	\item \textbf{res.append(field[, value])} \\ Berfungsi untuk menambahkan \textit{value} tertentu pada \textit{HTTP response header}.
	
	\item \textbf{res.get(field)} \\ Berfungsi untuk mengembalikan \textit{HTTP response header} yang dispesifikasikan oleh \textit{field}.
	
	\item \textbf{res.json([body])} \\ Akan mengembalikan body dari \textit{json} tertentu.
	
	\item \textbf{res.send([body])} \\ Berfungsi untuk mengembalikan respon \textit{HTTP}.
\end{itemize}

Berikut merupakan contoh implementasi dari beberapa \textit{method} tersebut:

\begin{lstlisting}
	//append
	res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	
	//get
	res.get('Content-Type');
	
	//json
	res.json({ user: 'tobi' });
	
	
\end{lstlisting}

\subsection{Router}
Objek dari kelas \textit{Router} merupakan \textit{instance} dari \textit{middleware} dan \textit{routes}. Setiap aplikasi \textit{Express} memiliki \textit{router} secara \textit{built-in}. 

Salah satu \textit{method} yang dimiliki oleh kelas \textit{Router} yaitu : 

\begin{itemize}
	\item \textbf{router.route(path)} \\ Berfungsi untuk mengembalikan sebuah \textit{instance} dari satu \textit{route} yang dapat digunakan untuk menangani \textit{HTTP verbs} dengan sebuah \textit{middleware} opsional.
	
\end{itemize}

Berikut merupakan contoh implementasi dari \textit{method} tersebut:

\begin{lstlisting}
	var router = express.Router();
	
	router.route('/users/:user_id')
	.all(function(req, res, next) {
	// runs for all HTTP verbs first
	// think of it as route specific middleware!
	next();
	})
	.get(function(req, res, next) {
	res.json(req.user);
	})
\end{lstlisting}

%------------- END OF EXPRESS.JS--------------- 

\section{Canvas API}
\label{sec:Canvas API}
 
Canvas API merupakan salah satu elemen \textit{HTML5} yang digunakan untuk membuat gambar grafis dalam aplikasi web \cite{canvas}. Teknologi ini memiliki fitur untuk membuat komposisi foto, membuat animasi, dan membuat \textit{real-time video processiong} atau \textit{rendering}. 

Subbab-subbab berikut menjelaskan tentang beberapa \textit{interface} dari \textit{Canvas}.

\subsection{HTMLCanvasElement}
\textit{Interface} ini menyediakan beberapa properti dan \textit{method} untuk memanipulasi tata letak dan tampilan dari elemen \textit{canvas}.

Beberapa properti yang dimiliki oleh \textit{HTMLCanvasElement} yaitu : 

\begin{itemize}
	\item \textbf{HTMLCanvasElement.height} \\ Merupakan bilangan integer positif yang merepresentasikan tinggi dari atribut \textit{HTML} pada elemen \textit{canvas} yang diinterpretasikan dalam piksel \textit{CSS}. Apabila atribut tidak didefinisikan, atau atribut diisi dengan nilai negatif, maka akan digunakan nilai \textit{default} yaitu 150.
	\item \textbf{HTMLCanvasElement.width} \\ Merupakan bilangan integer positif yang merepresentasikan lebar dari atribut \textit{HTML} pada elemen \textit{canvas} yang diinterpretasikan dalam piksel \textit{CSS}. Apabila atribut tidak didefinisikan, atau atribut diisi dengan nilai negatif, maka akan digunakan nilai \textit{default} yaitu 300.
\end{itemize}

Beberapa \textit{method} yang dimiliki oleh \textit{HTLMCanvasElement} yaitu : 

\begin{itemize}
	\item \textbf{HTMLCanvasElement.getContext()} \\ \textit{Method} ini akan mengembalikan konteks \textit{drawing} pada \textit{canvas}, atau mengembalikan \textit{null} apabila konteks \textit{ID} tidak tersedia. Konteks \textit{drawing} berfungsi untuk dapat menggambar pada \textit{canvas}.
	\item \textbf{HTMLCanvasElemen.toBlob()} \\ \textit{Method} ini akan membuat objek \textit{Blob} yang merepresentasikan gambar yang ada pada \textit{canvas}. 
	
\end{itemize}


\subsection{CanvasRenderingContext2D}
\textit{Interface} ini digunakan untuk menggambar persegi panjang, teks, gambar, dan objek-objek lain kedalam elemen \textit{canvas}. \textit{CanvasRenderingContext2D} menyediakan konteks \textit{2D rendering} untuk suatu elemen \textit{<canvas>}.
Untuk mendapatkan objek dari \textit{interface} ini, harus memanggil \textit{getContext()} didalam elemen \textit{<canvas>}, dengan memberi ''2d'' sebagai argumen. Berikut contoh penggunaannya :

\begin{lstlisting}
	var canvas = document.getElementById('myCanvas');
	var ctx = canvas.getContext('2d');
\end{lstlisting}

\subsubsection{Rectangles}
Ada tiga \textit{method} yang dapat digunakan untuk menggambar bentuk persegi panjang:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.clearRect()} \\ Berfungsi untuk mengatur semua piksel dalam persegi panjang yang didefinisikan dengan titik awal (x,y) dan ukuran (lebar, tinggi) menjadi hitam transparan, dan menghapus semua konten yang telah digambar sebelumnya.
	\item \textbf{CanvasRenderingContext2D.fillRect()} \\ Berfungsi untuk menggambar persegi panjang dengan berisi warna tertentu, pada posisi (x,y) dengan ukuran yang ditentukan dari \textit{width} dan \textit{height}.
	\item \textbf{CanvasRenderingContext2D.strokeRect()} \\ Berfungsi untuk menggambar hanya garis luar dari persegi panjang, pada posisi (x,y) dengan ukuran yang ditentukan dari \textit{width} dan \textit{height}.
\end{itemize}

\subsubsection{Text}
Berikut merupakan beberapa \textit{method} yang digunakan untuk menggambar suatu teks:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.fillText()} \\ Menggambar teks tertentu pada posisi (x,y).
	\item \textbf{CanvasRenderingContext2D.strokeText()} \\ Menggambar garis luar dari suatu teks pada posisi (x,y).
\end{itemize}

\subsubsection{Line Styles}
Berikut merupakan beberapa properti yang digunakan untuk mengatur bagaimana sebuah garis akan digambar:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.lineWidth} \\ Properti yang merepresentasikan tebal dari suatu garis. Nilai \textit{default} dari properti ini yaitu 1.0.
	\item \textbf{CanvasRenderingContext2D.lineCap} \\ Berfungsi untuk menentukan jenis ujung dari suatu garis. Nilai dari properti ini dapat berupa \textit{round}, \textit{square}, atau \textit{butt}. 
\end{itemize}

\subsubsection{Text Styles}
Berikut merupakan beberapa properti yang digunakan untuk mengatur bagaimana suatu teks digambar.

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.font} \\ Berfungsi untuk mengatur jenis \textit{font} yang akan digunakan. Nilai \textit{default} dari properti ini yaitu 10px \textit{sans-serif}.
	\item \textbf{CanvasRenderingContext2D.textAlign} \\ Berfungsi untuk mengatur penjajaran dari suatu teks.
	\item \textbf{CanvasRenderingContext2D.direction} \\  Berfungsi untuk mengatur arah dari teks tertentu. Nilai dari properti ini dapat berupa kiri-ke-kanan, atau kanan-ke-kiri.
\end{itemize}

\subsubsection{Fill and Stroke Styles}
\textit{Fill style} digunakan untuk memanipulasi warna dan \textit{style} pada suatu bentuk, dan \textit{stroke style} digunakan untuk memanipulasi garis luar pada suatu bentuk.

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.fillStyle} \\ Berfungsi untuk memberi warna yang akan digunakan didalam suatu bentuk tertentu.
	\item \textbf{CanvasRenderingContext2D.strokeStyle} \\ Berfungsi untuk memberi warna yang akan digunakan pada garis luar suatu bentuk tertentu.
\end{itemize}

\subsubsection{Gradients and Patterns}

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.createLinearGradient()} \\ Berfungsi untuk membuat \textit{linear gradient} sepanjang garis pada koordinat tertentu.
	\item \textbf{CanvasRenderingContext2D.createRadialGradient()} \\ Berfungsi untuk membuat \textit{radial gradient} pada koordinat tertentu.
	\item \textbf{CanvasRenderingContext2D.createPattern()} \\ Berfungsi untuk membuat pola dengan menggunakan gambar yang sudah didefinisikan sebelumnya.
\end{itemize}

\subsubsection{Paths}
Beberapa \textit{method} berikut ini dapat digunakan untuk memanipulasi \textit{path} dari suatu objek:

\begin{itemize}
	\item \textbf{CanvasRenderingContext2D.beginPath()} \\ Berfungsi untuk memulai \textit{path} baru dengan mengosongkan daftar dari \textit{sub-paths}.
	\item \textbf{CanvasRenderingContext2D.closePath()} \\ Berfungsi untuk memindahkan posisi ujung \textit{pen} ke titik awal dari \textit{sub-path} saat ini.
	\item \textbf{CanvasRenderingContext2D.moveTo()} \\ Berfungsi untuk memindahkan posisi ujung \textit{pen} saat ini ke koordinat (x,y).
	\item \textbf{CanvasRenderingContext2D.lineTo()} \\ Berfungsi untuk menghubungkan titik terakhir pada \textit{sub-path} ke koordinat (x,y).
	\item \textbf{CanvasRenderingContext2D.arc()} \\ Berfungsi untuk menambahkan garis lengkung ke \textit{path} yang berpusat pada posisi (x,y) dengan radius \textit{r}, dimulai dari \textit{startAngle} dan berakhir pada \textit{endAngle} dengan arah gambar garis lengkung yang didefinisikan oleh \textit{anticlockwise}.
	\item \textbf{CanvasRenderingContext2D.rect()} \\ Berfungsi untuk membuat \textit{path} persegi panjang pada posisi (x,y) dengan ukuran yang didefinisikan oleh \textit{width} dan \textit{height}.
\end{itemize}




